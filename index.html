<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Joinself Docs</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.115.4"><meta name=description content="Joinself Docs - Joinself - Platform Documentation "><meta name=theme-name content="dot-hugo"><link rel=stylesheet href=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://docs.joinself.com/plugins/themify-icons/themify-icons.css><link rel=icon href=https://docs.joinself.com/images/favicon.png type=image/x-icon><link href="https://fonts.googleapis.com/css?family=Barlow:300,400,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.js></script><style>:root{--primary-color:#0e1c42;--body-color:#f9f9f9;--text-color:#636363;--text-color-dark:#0e1c42;--white-color:#ffffff;--light-color:#f8f9fa;--font-family:Barlow}</style><link href=https://docs.joinself.com/css/style.min.css rel=stylesheet media=screen><script src=https://docs.joinself.com/plugins/jquery/jquery-1.12.4.js></script>
<script src=https://docs.joinself.com/plugins/jquery/jquery-ui.js></script>
<script src=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://docs.joinself.com/plugins/match-height/jquery.matchHeight-min.js></script><meta property="og:image" content="https://docs.joinself.com/images/logo.png"><meta property="og:image:width" content="57"><meta property="og:image:height" content="35"><meta property="og:image:type" content="image/png"><meta name=twitter:title content="Joinself Docs"><meta name=twitter:description content="Joinself - Platform Documentation"><meta property="og:title" content="Joinself Docs"><meta property="og:description" content="Joinself - Platform Documentation"><meta property="og:type" content="website"><meta property="og:url" content="https://docs.joinself.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Joinself Docs"><meta name=twitter:description content="Joinself - Platform Documentation"></head><body><header class="banner overlay bg-cover" data-background=https://docs.joinself.com/images/header.png><nav class="navbar navbar-expand-md navbar-dark"><div class="container px-2 px-md-0"><div class=navbar-brand-container><a class="navbar-brand px-2" href=/><img class=img-fluid src=https://docs.joinself.com/images/logo_white.png alt="Joinself - Platform Documentation">
<i class=navbar_docs_title>Docs</i></a></div><button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation aria-controls=navigation aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class="nav-link text-dark" href=https://www.joinself.com>Home</a></li><li class=nav-item><a class="nav-link text-dark" href=https://www.joinself.com/contact-us>contact</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle text-dark" href=# role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>docs</a><div class=dropdown-menu><a class=dropdown-item href=https://docs.joinself.com/quickstart/>Quick Start</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/>SDK Reference</a><div class=separator>Products</div><a class=dropdown-item href=https://docs.joinself.com/sdk/authentication/>Authentication</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/messaging/>Messaging</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/facts/>Facts</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/zero/>Zero-knowledge</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/documentsign/>Document sign</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/directconnection/>Direct connection</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/voice/>Voice calls</a></div></li></ul><div class=btn-get-keys><a href=https://developer.sandbox.joinself.com target=_blank class=btn>GET API Keys</a></div></div></div></nav><div class="container section"><div class=row><div class="col-lg-8 text-center mx-auto"><h1 class="text-white mb-3">Welcome to the Docs</h1><p class="text-white mb-4">Here you&rsquo;ll find guides, resources, and references to build with Self.</p><div class=position-relative><input id=search class=form-control placeholder="Have a question? Just ask here or enter terms">
<i class="ti-search search-icon"></i>
<script>$.ui.autocomplete.filter=function(e,t){var n=new RegExp("(^| )"+$.ui.autocomplete.escapeRegex(t),"i");return $.grep(e,function(e){return n.test(e.label)||n.test(e.value)||n.test(e)})},$(function(){var e=[{value:"Commercial Terms and Conditions v1.3",label:`<p>These Self Commercial Terms and Conditions includes this introduction, the General Terms, Definitions, Services Terms, and incorporated documents and terms (“Agreement”) and forms a legal agreement between Self Group Limited (“Self”)and the entity or sole proprietor on whose behalf a Self Organisation Account is created (“you” and “your”) This Agreement states the terms and conditions that apply to your use of the Services.
This Agreement is effective upon the date you first access or use the Services (“Effective Date”) and continues until you or Self terminates it (this period, the “Term”). Before creating an account and becoming a Commercial User of Self, you must agree to these terms and conditions. Please read them carefully first.
Capitalised terms used in this Agreement that are not defined inline are defined in the Definitions.
General Terms Last modified: June 20th 2023
You and Self agree as follows:
1.1 Your use of Self These terms and conditions set out the basis upon which we are providing the Network for use by you as a Commercial User. They shall be deemed to include any additional terms and conditions referred to herein or provided by us from time to time unless explicitly excluded.
For the purposes of these terms and conditions, references to “the Network” shall also be deemed to include reference to services and documentation provided by us through the Network, including but not limited to the Self Network, the Developer Portal, Open Source tools and software (separately licenced) and the Self App and Embedded Self App.
1.2 Eligibility. Only businesses (including sole proprietors) and non-profit organisations located in one of the list of countries provided on the country list posted on our website at https://docs.joinself.com/agreements/Country_Availability/ are eligible to apply for a Self Organisation Account and use the Services. These commercial terms and conditions only apply to the use of Self eligible Commercial Users. For the purposes of these Terms and Conditions, references to “Organisation” will cover all types of Commercial User.
1.3 Business Representative.
You and your “Representative” (the Individual Self User submitting the application for a Self Organisation Account) individually affirm to Self that (a) your Representative is authorised to provide User Information on your behalf and to bind you to this Agreement; and (b) your Representative is an executive officer, director, senior manager or otherwise has significant responsibility for the control, management or direction of your business. Self may require you or your Representative to provide additional information or documentation demonstrating your Representative’s authority.
1.4 Sole Proprietors. If you are a sole proprietor, you and your Representative also affirm that your Representative is personally responsible and liable for your use of the Services and your obligations to Customers, including payment of amounts you owe under this Agreement.
1.5 Age Requirements. If you are a sole proprietor, and you are not old enough to enter into a contract on your own behalf (which is commonly but not always 18 years old), but you are 13 years old or older, your Representative must be your parent or legal guardian. If you are a legal entity that is owned, directly or indirectly, by an individual who is not old enough to enter into a contract on their own behalf, but the individual is 13 years old or older, your Representative must obtain the consent of either your board or an authorised officer. The approving board, authorised officer, parent or legal guardian is responsible to Self and is legally bound to this Agreement as if it had agreed to this Agreement itself. You must not use the Services if you are under 13 years of age. Self is currently only intended for people who can legally consent to their data being processed. Typically this means being over the age of 13. By agreeing to these terms and conditions you understand this restriction regarding the data you may seek to verify.
2. Network and Support. 2.1 Services. Self will make available to you the Services, and give you access to the Self Portal.
2.2 Services Terms; Order of Precedence The Services Terms contain specific terms governing the parties’ rights and obligations related to the Services described in those Services Terms. If there are no Services Terms for a particular Self service, then only these General Terms govern. By accessing or using a Service, you agree to comply with the applicable Services Terms. If any term in these General Terms conflicts with a term in any Services Terms or set of terms incorporated by reference into this Agreement, then unless terms of lower precedence expressly state to the contrary, the order of precedence is: (a) the Services Terms; (b) these General Terms; and (c) all terms incorporated by reference into this Agreement. Your access to or use of the Services may also be subject to additional terms which will be made available to you online and with which you will agree through the Self Portal
2.3 Service Modifications and Updates. Self may modify the Services and Network at any time, including adding or removing functionality or imposing conditions on use of the Network. Self will notify you of material adverse changes in, deprecations to, or removal of functionality from the Services you are using or the Network. Self is not obligated to provide any Updates. However, if Self makes an Update available, you must fully install the Update by the date or within the time period stated in Self’s notice; or, if there is no date or period stated in the notice, then no later than 30 days after the date of the notice.
2.4 Subcontracting. Self may subcontract its obligations under this Agreement to third parties.
2.5 Your obligations when using Self You agree to ensure that any and all information and material which you share through the Network is accurate (where it states facts); is genuinely held (where it states opinions) and complies with the law applicable in England and Wales and in any country from which it is posted.
You must not and agree not to:
use the Network in any unlawful manner, for any unlawful purpose, or in any manner inconsistent with these terms and conditions, or act fraudulently or maliciously or in a way likely to deceive any person; use the Network for any purpose other than those envisaged in the Services Terms for the Services you are using; infringe our intellectual property rights or those of any third party in relation to your use of the Network, including by the submission of any information or material (to the extent that such use is not licensed by these terms); transmit any material that is defamatory, offensive or otherwise objectionable in relation to your use of the Network; use the Network in a way that could damage, disable, overburden, impair or compromise our systems or security or interfere with other users; collect or harvest any information or data from the Network or our systems or attempt to decipher any transmissions to or from the systems comprising the Network; disassemble, de-compile, reverse engineer or create derivative works based on the whole or any part of the Network nor attempt to do any such things. copy, reproduce, republish, upload, post, transmit, resell, or distribute in any way, any part of the Services, Network, Documentation, or the Self Website except as permitted by Law. 2.6 Beta Services. The current release of Self is a Public Beta, that means that while it is a finished product, the Services may be feature-incomplete or contain bugs. You are free to use Self as intended, but we won’t be liable in the event that a problem is the result of your reliance on a public beta release of our software.
Self may describe limitations that exist within a Beta Service; however, your reliance on the accuracy or completeness of these descriptions is at your own risk. You should not use Beta Services in a production environment until and unless you understand and accept the limitations and flaws that may be present in the Beta Services.
2.7 Support. Self will provide you with support to resolve general issues relating to your Self Organisation Account and your use of the Network through resources and documentation that Self makes available on the Self Website and in the Portal. Self is not responsible for providing support to your customers.
3. Information 3.1 User Information. Upon Self’s request, you must provide User Information to Self in a form satisfactory to Self. You must keep the User Information in your Self Account current. You must promptly update your Self Account with any changes affecting you, the nature of your business activities, your Representative, beneficial owners, principals, or any other pertinent information.
3.2 Information Retrieved by Self. You authorise Self to retrieve information about you and your business from Self’s service providers and other third parties, including credit reporting agencies, banking partners and information bureaus, and you authorise and direct those third parties to compile and provide that information to Self. This information may include your, or your Representative’s, name, addresses, credit history, banking relationships, and financial history.
4. Fees and Taxes. 4.1 Services Fees. The Fees applicable to the Services you use (“Fees”) are stated on the Self Pricing Page, unless you and Self otherwise agree in writing. Self may revise the Fees at any time. If Self revises the Fees for a Service that you are currently using, Self will notify you at least 30 days (or a longer period if Law requires) before the revised Fees apply to you.
4.2 Collection of Fees and Other Amounts. You must pay, or ensure that Self is able to collect, Fees and other amounts you owe under this Agreement when due.
4.3 Taxes. Self’s published Fees exclude all Taxes.
5. Intellectual property 5.1 IP Rights All intellectual property rights in the Network belong to Self Group and the rights in the Network are licensed (not sold) to you. You have no intellectual property rights in, or to, the Network, the documentation or the services other than the right to use them in accordance with these terms.
5.2 Open Source Open Source software provided by Self Group is licenced separately and your rights in respect of any Self Group Open Source software are governed by the relevant Open Source Licence.
6. Termination; Suspension; Survival. 6.1 Termination. Termination by You; You may terminate this Agreement at any time by closing your Self Organisation Account. To do so, you will need to contact Self support and request an account termination and stop using the Services. Provided that; A Self Organisation Account cannot be closed and a Service cannot be terminated whilst a contract between the Organisation and another Member is still in force. In that instance the Agreement will be terminated at the earliest possible opportunity and, outside of the ongoing contract, additional Services or use of the Network will no longer be possible pending termination. Termination by Self; Self may terminate this Agreement at any time for any or no reason by providing you with 30 days notice of Termination. Self may terminate this Agreement if Self exercises its right to suspend Services (including under Section 6.2 of these General Terms) and does not reinstate the suspended Services within 30 days. Self may Terminate this Agreement without notice if any event listed in Sections 6.2(a)–(h) of these General Terms occurs and Self determines that the breach occasioning termination cannot be remedied within 30 days.. Termination for Material Breach. A party may terminate this Agreement immediately upon notice to the other parties if any of the other parties materially breaches this Agreement, and if capable of cure, does not cure the breach within 10 days after receiving notice specifying the breach. If the material breach affects only certain Services, the non-breaching party that served the notice may choose to terminate only the affected Services. Effect on Other Agreements. Unless stated to the contrary, termination of this Agreement will not affect any other agreement between the parties. 6.2 Suspension. Self may immediately suspend providing any or all Services to you, and your access to the Self Technology, if:
Self believes it will violate any Law; a Governmental Authority requires or directs Self to do so; you do not update in a timely manner your implementation of the Services or Self Technology to the latest production version Self recommends or requires; you do not respond in a timely manner to Self’s request for User Information or do not provide Self adequate time to verify and process updated User Information. you breach this Agreement or any other agreement between the parties; you enter an Insolvency Proceeding; Self believes that you are engaged in a business, trading practice or other activity that presents an unacceptable risk to Self; or Self believes that your use of the Services (i) is or may be harmful to Self or any third party; (iv) degrades, or may degrade, the security, stability or reliability of the Self services, Self Technology or any third party’s system (e.g., your involvement in a distributed denial of service attack); (v) enables or facilitates, or may enable or facilitate, illegal or prohibited transactions; or (vi) is or may be unlawful. 6.3 Survival. The following will survive termination of this Agreement:
provisions that by their nature are intended to survive termination (including Sections 4, 7.2, 9.4,and 11 of these General Terms); and provisions that allocate risk, or limit or exclude a party’s liability, to the extent necessary to ensure that a party’s potential liability for acts and omissions that occur during the Term remains unchanged after this Agreement terminates. 7. Use Rights. 7.1 Use of Services. Subject to the terms of this Agreement, Self grants you a worldwide, non-exclusive, non-transferable, non-sublicensable, royalty-free licence during the Term to access the Documentation, and access and use the Network, as long as your access and use is (a) solely as necessary to use the Services; (b) solely for your business purposes; and (c) in compliance with this Agreement and the Documentation.
7.2 Feedback. During the Term, you may provide suggestions, ideas, comments and other input (collectively ” Feedback”) to Self. You grant to Self, on your behalf, a perpetual, worldwide, non-exclusive, irrevocable, royalty-free licence to exploit that Feedback for any purpose, including developing, improving, manufacturing, promoting, selling and maintaining the Self services. All Feedback is Self’s confidential information.
7.3 Marks Usage. Subject to the terms of this Agreement, Self grants to you and your Affiliates, and you grant to Self and its Affiliates, a worldwide, non-exclusive, non-transferable, non-sublicensable, royalty-free licence during the Term to use the Marks of the grantor party or its Affiliate solely to identify Self as your service provider. Accordingly, Self and its Affiliates may use those Marks
on Self webpages and apps that identify Self’s customers; in Self sales/marketing materials and communications; and in connection with promotional activities to which the parties agree in writing. When using Marks of Self or its Affiliate, you must comply with the Self Marks Usage Terms and all additional usage terms and guidelines that Self provides to you in writing (if any). All goodwill generated from the use of Marks will inure to the sole benefit of the Mark owner.
7.4 No Joint Development; Reservation of Rights. Any joint development between the parties will require and be subject to a separate agreement between the parties. Nothing in this Agreement assigns or transfers ownership of any IP Rights to any party. All rights (including IP Rights) not expressly granted in this Agreement are reserved.
8. Privacy and Data Use. 8.1 Privacy Policies. Self’s Privacy Policy explains how and for what purposes Self collects, uses, retains, discloses and safeguards the Personal Data you provide to Self.
8.2 Personal Data. Personal Data means any information relating to an identifiable natural person that is Processed in connection with the Services, and includes “personal data” as defined in the GDPR and UK GDPR and “personal information” as defined in the CCPA. Collectively it is known herein as (“Personal Data”).
There should be no circumstance under which Personal Data should be provided to Self by you directly without the involvement of the individual to whom the data pertains. Self will not sell or lease Personal Data that Self receives from you to any third party in accordance with Self’s Privacy Policy.
8.3 Protected Data. To the extent Law permits, Self will use Protected Data to (a) secure, provide, provide access to, and update the Self services; (b) fulfil its obligations under Law, and comply with Governmental Authority requirements and requests; and (c) prevent and mitigate fraud, financial loss, and other harm.
Self is not obligated to retain Protected Data after the Term, except as (a) required by Law (b) required for Self to perform any post-termination obligations; (c) this Agreement otherwise states; or (d) the parties otherwise agree in writing. You are responsible for being aware of and complying with Law governing your use, storage and disclosure of Protected Data.
8.4 Data Processing Agreement. The Data Processing Agreement, including the Approved Data Transfer Mechanisms (as defined in the Data Processing Agreement) that apply to your use of the Services and transfer of Personal Data, is incorporated into this Agreement by this reference. Each party will comply with the terms of the Data Processing Agreement and will train its employees on DP Law.
9. Data Security. 9.1 Controls. Each party will maintain commercially reasonable administrative, technical, and physical controls designed to protect data in its possession or under its control from unauthorised access, accidental loss and unauthorised modification. You are responsible for implementing administrative, technical, and physical controls that are appropriate for your business.
9.2 Data Breach. You must notify Self immediately if you become aware of an unauthorised acquisition, modification, disclosure, access to, or loss of Personal Data on your systems.
10. Representations and Warranties. 10.1 Representations and Warranties. You represent as of the Effective Date, and warrant at all times during the Term, that
you have the right, power, and ability to enter into and perform under this Agreement. you are an Organisation located in an eligible jurisdiction and are eligible to apply for a Self Organisation Account and use the Network; your employees, contractors and agents are acting consistently with this Agreement; your use of the Services does not violate or infringe upon any third-party rights, including IP Rights; you comply with the Law with respect to your business, your use of the Services and the Network, and the performance of your obligations in this Agreement; you comply with the Documentation; all information you provide to Self, including the User Information, is accurate and complete. 10.2 Scope. The representations and warranties in Sections 2.5 and 10.1 of these General Terms apply generally to your performance under this Agreement. Additional representations and warranties that apply only to a specific Service may be included in the Services Terms.
11. Disclaimer and Limitations on Liability. The following disclaimer and limitations will apply notwithstanding the failure of the essential purpose of any limited remedy.
11.1 Disclaimer. Self provides the Services and the Network “AS IS” and “AS AVAILABLE”. Except where expressly stated as a “warranty” in this Agreement, and to the maximum extent permitted by the Law, Self does not make any, and expressly disclaims all, express and implied warranties and statutory guarantees with respect to its performance under this Agreement, the Services, the Network and the Documentation, including as related to availability, the implied warranties of fitness for a particular purpose, merchantability and non-infringement, and the implied warranties arising out of any course of dealing, course of performance or usage in trade. The Self Parties are not liable for any losses, damages, or costs that you or others may suffer arising out of or relating to hacking, tampering, or other unauthorised access or use of the Services, your Self Account, or Protected Data, or your failure to use or implement anti-fraud or data security measures. Furthermore, the Self Parties are not liable for any losses, damages, or costs that you or others may suffer arising out of or relating to
your access to, or use of, the Services in a way that is inconsistent with this Agreement or the Documentation; unauthorised access to servers or infrastructure, or to Self Data or Protected Data; Service interruptions or stoppages; bugs, viruses, or other harmful code that may be transmitted to or through the Service errors, inaccuracies, omissions or losses in or to any Protected Data or Self Data; Content; or your or another party’s defamatory, offensive, fraudulent or illegal conduct. 11.2 Limitations On Liability. Indirect Damages; To the maximum extent permitted by the Law, the Self Parties will not be liable to you in relation to this Agreement or the Services during and after the Term (whether in contract, negligence, strict liability or tort, or on other legal or equitable grounds) for any lost profits, personal injury, property damage, loss of data, business interruption, indirect, incidental, consequential, exemplary, special, reliance, or punitive damages, even if these losses, damages, or costs are foreseeable, and whether or not you or the Self Parties have been advised of their possibility. General Damages; To the maximum extent permitted by the Law, the Self Parties will not be liable to you in relation to this Agreement or the Services during and after the Term (whether in contract, negligence, strict liability or tort, or on other legal or equitable grounds) for losses, damages, or costs exceeding in the aggregate the greater of (i) the total amount of Fees you paid to Self during the 3-month period immediately preceding the event giving rise to the liability; and (ii) $500 USD. 11.3 Service Availability Self is designed to be reliable and available, and we aim to ensure you are able to access the Network at all times, but your use of the Network may be interrupted or delayed from time to time by updates to or maintenance of the Network or our systems, by failures of third party systems, or by other events outside of our control. As a result we cannot guarantee that the Network will always be available.
The Network may only be available in certain coverage areas, and there may be areas where coverage is limited. We will do our best to ensure this is not the case, but this may be outside our control.
If our provision of the Network is interrupted or delayed please check our Network Status page in your developer portal or on our website. Severe outages will be notified using our social channels and we will take steps to minimise the effect of the interruption or delay, but we will not be liable under any circumstances for any loss or damage arising from a service interruption or delay, including any business interruption, or loss of profit or business opportunity. We will not be liable for any contract with a customer failing to proceed because the Network is not accessible at any particular time. We may at our absolute discretion at any time and without telling you first decide to update, change or terminate the Network or its availability to you and we shall not be liable to you in respect of any losses you might suffer as a result.
12. Modifications to this Agreement. Self may modify all or any part of this Agreement at any time by posting a revised version of the modified General Terms (including the introduction to this Agreement and the Definitions), Services Terms or terms incorporated by reference on the Self Legal Page or by notifying you. The modified Agreement is effective upon posting or, if Self notifies you, as stated in the notice. By continuing to use Services after the effective date of any modification to this Agreement, you agree to be bound by the modified Agreement. It is your responsibility to check the Self Legal Page regularly for modifications to this Agreement. Self last modified these General Terms on the date listed under the “General Terms” heading, and each set of Services Terms on the date listed under the heading for those terms. Except as this Agreement (including in this Section 14) otherwise allows, this Agreement may not be modified except in writing signed by the parties.
13. General Provisions. 13.1 Electronic Communications. By accepting this Agreement or using any Service, you confirm your consent to;
receive Communications electronically; and the use of electronic signatures. If you choose not to consent to this or if you withdraw your consent, you may be unable to use the Services.
Examples of Communications include:
Any disclosure statement governing your use of the Services; Any disclosure required by Law; Billing statements, receipts and account history reports; Letters, notices and alerts regarding the Services and any changes to the Services; and Other disclosures, notices and communications in connection with (a) your application for the Services; (b) your Self Organisation Account; (c) account maintenance; or (d) servicing and collection of funds. Unless the Law otherwise requires, or Self otherwise agrees, Self may provide Communications to you by:
posting them on the Self Website; notifying you through the Services, your Self Portal or any Self application; sending a message to the Self Account of a User registered as an owner or operator of the relevant Self Organisation Account; or sending an email to the email address listed in the applicable Self Organisation Account; 13.2 Notices and Communications. Notices to Self. Unless this Agreement states otherwise, for notices to Self, you must contact us using Self Messaging. A notice you send to Self can be verifiably identified as having been received by a duly authorised Self User. Communications to you. Self will always communicate with you in the first instance through Self messaging. A Communication Self sends to you through Self Messaging can be verifiably identified as having been received by you when you receive it. Self may also communicate with you electronically through its website or by email such communication shall be deemed received by you on the earliest of (i) when posted to the Self Website or Self Portal; and (ii) when sent by email. 13.4 Collection Costs. You are liable for all costs Self incurs during collection of any amounts you owe under this Agreement, in addition to the amounts you owe. Collection costs may include legal fees and expenses, costs of any arbitration or court proceeding, collection agency fees, applicable interest, and any other related cost.
13.5 Interpretation. All references in this Agreement to any terms, documents, or Legislation are to those items as they may be amended, supplemented or replaced from time to time. All references to APIs and URLs are references to those APIs and URLs as they may be updated or replaced. The section headings of this Agreement are for convenience only and have no interpretive value. Unless expressly stated otherwise, any consent or approval that may be given by a party (i) is only effective if given in writing and in advance; and (ii) may be given or withheld in the party’s sole and absolute discretion. References to “business days” means weekdays on which banks are generally open for business. Unless specified as business days, all references in this Agreement to days, months or years mean calendar days, calendar months or calendar years. Unless expressly stated to the contrary, when a party makes a decision or determination under this Agreement, that party has the right to use its sole discretion in making that decision or determination. This agreement does not give rise to any rights under the Contracts (Rights of Third Parties) Act 1999 to enforce any term of this agreement. Each of the paragraphs of these terms operates separately. If any court or relevant authority decides that any of them are unlawful, the remaining paragraphs will remain in full force and effect. Even if we delay in enforcing this contract, we can still enforce it later. If we do not insist immediately that you do anything you are required to do under these terms, or if we delay in taking steps against you in respect of your breaking this contract, that will not mean that you do not have to do those things and it will not prevent us taking steps against you at a later date. These terms are governed by English law and we must each bring legal proceedings in respect of the Network (whether contractual or non-contractual) in the English courts. No Agency; Each party is an independent contractor. Nothing in this Agreement serves to establish a partnership, joint venture, or general agency relationship between Self and you. You are contracting with Self Group Limited, a company registered in England with number 11855548 and whose address is at Harwood House, 43 Harwood Road, London, SW6 4QP. 13.6 Waivers. To be effective, a waiver must be in a writing signed by the waiving party. The failure of any party to enforce any provision of this Agreement will not constitute a waiver of that party’s rights to subsequently enforce the provision.
13.7 Force Majeure. Self will not be liable for any losses, damages, or costs you suffer, or delays in Self’s performance or non-performance, to the extent caused by a Force Majeure Event.
For the purpose of this Agreement, Force Majeure means an event beyond the control of Self, including a strike or other labour dispute; labour shortage, stoppage or slowdown; supply chain disruption; embargo or blockade; telecommunication breakdown; power outage or shortage; inadequate transportation service; inability or delay in obtaining adequate supplies; weather; earthquake; fire; flood; act of God; riot; civil disorder; civil or government calamity; epidemic; pandemic; state or national health crisis; war; invasion; hostility (whether war is declared or not); terrorism threat or act; Law; or act of a Governmental Authority.
13.8 Complaints and Disputes If you have a complaint regarding the service, please contact us at customerservice@joinself.com and try to resolve it informally. If you are not happy with how we have handled any complaint, you may wish to consider alternative dispute resolution which is a process where an independent body considers the facts of a dispute and seeks to resolve it, without you having to go to court. Disputes may be submitted for online resolution to the European Commission Online Dispute Resolution platform.
13.9 Entire Agreement. This Agreement constitutes the entire agreement and understanding of the parties with respect to the Services, and supersedes all prior and contemporaneous agreements and understandings.
Download as PDF
</p>`,url:"https://docs.joinself.com/agreements/commercial_terms_and_conditions_v1.3/"},{value:"Country Availability",label:`<p>The list below is the current list of countries to which Self can provide Services. Our Services are in Beta, and not all systems or document checks will be functional in all territories. This list forms part of any commercial Terms and conditions. If your Organisation is based outside of the countries in this list, Self will be unable to accept your application to join the Network or use our Services.
The United States and Canada
Canada United States Europe (31)
Austria Belgium Bulgaria Croatia Cyprus Czech Republic Denmark Estonia Finland Germany Greece Hungary Iceland Ireland Italy Latvia Lithuania Luxembourg Malta Netherlands Norway Poland Portugal Romania Slovakia Slovenia Spain Sweden Switzerland Ukraine United Kingdom Africa, Middle East, and India (2)
Israel South Africa Latin America and the Caribbean (0)
Asia Pacific (6)
Australia Japan Korea, Republic of New Zealand Singapore Vietnam Download as PDF
</p>`,url:"https://docs.joinself.com/agreements/country_availability/"},{value:"Data Processing Agreement",label:`<p>This Data Processing Agreement (“DPA”) is subject to and forms part of your Self Commercial Terms and Conditions and governs Self’s Processing of Personal Data.
1. Structure. Your Self Organisation Account is provided from the United Kingdom.
2. Definitions. Capitalised terms not defined in this DPA have the meanings given to them in your Self Commercial Terms and Conditions.
“CCPA” means the California Consumer Privacy Act of 2018, Cal. Civ. Code Sections 1798.100-1798.199.
“DP Law” means all Legislation that applies to Personal Data Processing under your Self Commercial Terms and Conditions and this DPA, including international, federal, state, provincial and local Law relating to privacy, data protection or data security.
“Data Controller” means the entity which, alone or jointly with others, determines the purposes and means of Processing Personal Data, which may include, as applicable, a “Business” as defined under the CCPA.
“Data Processor” means the entity that Processes Personal Data on behalf of the Data Controller, which may include, as applicable, a “Service Provider” as defined under the CCPA.
“Data Security Measures” means technical and organisational measures that are intended to secure Personal Data to a level of security appropriate for the risk of the Processing.
“Data Subject” means an identified or identifiable natural person to which Personal Data relates.
“EEA” means the European Economic Area.
“EEA SCCs” mean Module 2 (Transfer: Controller to Processor) of the standard contractual clauses set out in the European Commission Implementing Decision (EU) 2021/914 on standard contractual clauses for the transfer of personal data to third countries according to the GDPR.
“GDPR” means the General Data Protection Regulation (EU) 2016/679.
“Instructions” means this DPA and any further written agreement or documentation under which the Data Controller instructs a Data Processor to perform specific Processing of Personal Data for that Data Controller.
“Joint Controller” means a Data Controller that jointly determines the purposes and means of Processing Personal Data with one or more Data Controllers.
“Personal Data” means any information relating to an identified or identifiable natural person that is Processed in connection with the Services, and includes “personal data” as defined under the GDPR and “personal information” as defined under the CCPA.
“Process” means to perform any operation or set of operations on Personal Data or sets of Personal Data, such as collecting, recording, organising, structuring, storing, adapting or altering, retrieving, consulting, using, disclosing by transmission, disseminating or otherwise making available, aligning or combining, restricting, erasing or destroying, as described under DP Law.
“Sensitive Data” means (a) Personal Data that is genetic data, biometric data, data concerning health, a natural person&rsquo;s sex life or sexual orientation; or (b) data about racial or ethnic origin, political opinions, religious or philosophical beliefs, or trade union membership, to the extent this data is treated distinctly as a special category of Personal Data under DP Law.
“Sub-processor” means an entity a Data Processor engages to Process Personal Data on that Data Processor’s behalf in connection with the Services.
“UK Data Transfer Addendum” means the international data transfer addendum to the EEA SCCs issued by the United Kingdom’s Information Commissioner&rsquo;s Office.
“UK GDPR” means the GDPR, as transposed into United Kingdom national law by operation of section 3 of the European Union (Withdrawal) Act 2018 and as amended by the Data Protection, Privacy and Electronic Communications (Amendments etc.) (EU Exit) Regulations 2019.
3. Self as Data Processor and Data Controller. 3.1. Data Processing Roles. To the extent Self Processes Personal Data as a:
(a) Data Processor, it is acting as a Data Processor on behalf of you, the Data Controller; and
(b) Data Controller, it has the sole and exclusive authority to determine the purposes and means of Processing Personal Data it receives from or through you.
3.2. Categories of Data Subjects and Personal Data. (a) Data Subjects. Self may Process the Personal Data of your Customers, representatives and any natural persons who access or use your Self Organisation Account.
(b) Personal Data. Where applicable, Self may Process Payment Account Details, billing address, name, date/time/amount of transaction, device ID, email address, IP address/location, order ID, payment card details, tax ID/status, unique customer identifier, identity information including government issued documents (e.g., national IDs, driver’s licenses and passports).
(c) Sensitive Data. Where applicable, Self may Process facial recognition data.
3.3. Data Processing Purposes. (a) The purposes of Self’s Processing of Personal Data are when Self is operating in its capacity as a Data Processor for a Service, including:
(i) Taking payment for Services provided by Self to the Organisation; and
(ii)Processing Images for the purpose of determining a biometric match between two or more images of a User.
(b) The purposes of Self’s Processing of Personal Data in its capacity as a Data Controller are:
(iii) complying with Law, including applicable anti-money laundering screening and know-your-customer obligations; and
4. Self’s Obligations when Acting as a Data Processor. 4.1. Obligations. To the extent that Self is acting as a Data Processor for you, Self will:
(a) not sell, retain, use or disclose Personal Data for any purpose other than to comply with Law;
(b) ensure that all no persons will be authorised to Process Personal Data in the context of the Services.
Personal Data;
(c) Self holds no personal data belonging to Data Subjects. We will inform you of requests Self receives from Data Subjects exercising their applicable rights under DP Law to (i) access (e.g., right to know under the CCPA) their Personal Data; (ii) have their Personal Data corrected or erased. Self will direct the Data Subject to you as Data Controller using Self messaging;
(d) Self will inform you of each law enforcement request it receives from a Governmental Authority requiring Self to disclose Personal Data or participate in an investigation involving Personal Data;
(e) to the extent required by DP Law, provide you with reasonable assistance through appropriate technical and organisational measures, at your expense, to assist you in complying with your obligations under DP Law;
(f) implement and maintain an information security program and a data security incident management program that addresses how Self will manage a data security incident involving the accidental or unlawful destruction, loss, alteration or unauthorised disclosure of, or access to, Personal Data (“Incident”). If Self is required by Law to notify you of an Incident, then Self will notify you without unreasonable delay.
4.2 Disclaimer of Liability.
Notwithstanding anything to the contrary in your Self Commercial Terms and Conditions or this DPA, Self will not be liable for any claim made by a Data Subject arising from or related to Self’s acts or omissions, to the extent that Self was acting in accordance with your Instructions.
5. Conflict. If there is any conflict or ambiguity between the provisions of this DPA and the provisions of your Self Commercial Terms and Conditions regarding Personal Data Processing, the provisions of this DPA will prevail.
Download as PDF
</p>`,url:"https://docs.joinself.com/agreements/data_processing_agreement/"},{value:"Client Setup",label:`<p>What is self? Self is a free to use service that lets you prove you’re a real, live person and are who you say you are, all without revealing the detail of your identity. Self keeps your data safe, secure and anonymous.
How does it work? You download the Self mobile app for free and tell it some facts about you. Then you ask friends, family, colleagues or a recognised organisation (eg: a bank) to verify that your facts are true. Your name, age, location etc…
The facts are stored in your secret locker (personal data store) and are never shared with anyone, but when someone needs to know your age, Self can help you provide them with a verified answer, all while keeping your data safe, secure and anonymous.
</p>`,url:"https://docs.joinself.com/sdk/setup/"},{value:"Connections",label:`<p>Permit connections Allows incoming messages from specified identities.
@client.messaging.permit_connection &quot;1234567890&quot; err := selfsdk.MessagingService().PermitConnection(&quot;1234567890&quot;) let success = await sdk.messaging().permitConnection(&quot;1234567890&quot;) Permitting incomming connections only applies if you don&rsquo;t have a global connection (*) permission. If you do, you have to revoke it first.
Permit global connections You can permit connections from everyone using an “*”.
@client.messaging.permit_connection &quot;*&quot; err := selfsdk.MessagingService().PermitConnection(&quot;*&quot;) let success = await sdk.messaging().permitConnection(&quot;*&quot;) Revoke specific connection You can also revoke connections from a specific self identifier with:
@client.messaging.revoke_connection &quot;1234567890&quot; err := client.MessagingService().RevokeConnection(&quot;1234567890&quot;) let success = await sdk.messaging().revokeConnection(&quot;1234567890&quot;) Revoking a connection only applies if you don&rsquo;t have a global connection (*) permission setup. If you do, you have to revoke it first.
Revoke global connections Revoke connection permissions from everyone using an “*”.
@client.messaging.revoke_connection &quot;*&quot; err := client.MessagingService().RevokeConnection(&quot;*&quot;) let success = await sdk.messaging().revokeConnection(&quot;*&quot;) Listing connections You can list your app allowed connections.
@client.messaging.allowed_connections.each do |self_id| p &quot;- '#{self_id}'&quot; end connections, _ := client.MessagingService().ListConnections() log.Println(&quot;connected to:&quot;, connections) conns = await sdk.messaging().allowedConnections() sdk.logger.info(\` - connections : \${conns.join(&quot;,&quot;)}\`) </p><p>identity</p><p>app</p><p>connect</p><p>disconnect</p><p>permit</p><p>block</p>`,url:"https://docs.joinself.com/sdk/users/connections/"},{value:"Request",label:`<p>Authentication allows you to verify a user by its ID without storing any other information about it.
On this example we will know in advance the user Self Identifier, you&rsquo;ll need to allow the user introduce its ID on your application so you can proceed with this request.
Note that by default users won&rsquo;t be connected to your app, in those cases they won&rsquo;t be receiving any incoming request, so let them know they need to be connected in advance.
Blocking request Let&rsquo;s see an easy example on how to implement an authentication workflow with the different Self SDKs.
On this example we will opt for a blocking approach, where the main execution line waits for the user response to continue.
user = &quot;1112223334&quot; authenticated = @app.authentication.request(user).accepted? user := &quot;1112223334&quot; if resp, err != client.AuthenticationService().Request(user); err != nil { println(&quot;authentication rejected&quot;) return } authenticated := resp.Accepted let res = await client.authentication().request(&quot;1112223334&quot;) let authenticated = res.isAccepted() The user will receive
Non-blocking request In contrast to blocking auth requests, there are situations where you just want to continue your execution line and set up an observer to be executed as soon as a response is received.
Let&rsquo;s say you have a conventional registration process where you let your users register to your application by its email address but you delay the email confirmation until they get back to you. This allows your users to go through a quick registration process, while you delay the data confirmation process.
# Request lets you pass a block to be executed once a response is received @client.authentication.request selfid do |auth| return auth.accepted? # The user has rejected the authentication end // Go language provides you with goroutines to // implement a non-blocking approach go func() { res, err != client.AuthenticationService().Request(selfid) if err != nil { println(&quot;authentication rejected&quot;) return } println(res.Accepted) }() async() =&gt; { try { let res = await client.authentication().request(&quot;1112223334&quot;) if(res.isAccepted() == true) { client.logger.info(\`\${res.selfID} is now authenticated 🤘\`) } else if(res.accepted == false) { client.logger.warn(\`\${res.selfID} has rejected your authentication request\`) } else { client.logger.error(res.errorMessage) } } catch (error) { client.logger.error(error.toString()) } } Asynchronous requests This scenario is similar to non-blocking authentication, however, it’s not restricted to only one user.
Sending an asynchronous authentication request is pretty straightforward, you can do it with the async option.
This will return a conversation id identifying the authentication conversation, you should store it and catch it on a subscription, check Receiving authentication response - Subscribe section on how to manage this.
cid = @client. authentication. request(&quot;1112223334&quot;, async: true) client. AuthenticationService(). RequestAsync(&quot;1112223334&quot;, &quot;conversation_id&quot;) let res = await client. authentication(). request(&quot;1112223334&quot;, { 'async': true }) As you can see the asynchronously of this call is accomplished by an extra option or modifier Let&rsquo;s see on the next chapter what other modifiers provides the authentication workflow.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/request/"},{value:"Request",label:`<p>Blocking Same as with authentication there are situations where you want to block your execution line until the user responds to your fact request. For example, you may want to block a user&rsquo;s access to a certain space of your site until you verify its passport number.
This function blocks the execution line until the user responds with its verified email address.
def get_email(selfid) res = @client.facts.request(selfid, [:email_address]) return &quot;&quot; unless res.accepted? res.attestation_values_for(:email_address).first // Refer to Receiving fact response - Deal with request for more info rescue =&gt; e // An exception will be raised in case of a timeout or internal error return &quot;&quot; end resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, }) if err != nil { return &quot;&quot;, err } aa, err := resp.AttestationValuesFor(fact.FactEmail) if err != nil { return &quot;&quot;, err } println(aa[0]) try { let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }]) if (!res) { sdk.logger.warn(\`fact request has timed out\`) } else if (res.status === 'accepted') { let pn = res.attestationValuesFor('email_address')[0] sdk.logger.info(\`\${selfID} email address is &quot;\${pn}&quot;\`) } else { sdk.logger.warn(\`\${selfID} has rejected your authentication request\`) } } catch (error) { sdk.logger.error(error.toString()) } Non-blocking The sdk also allows us to send a fact request without blocking the execution line.
Same registration example we used for authentication works here, if you want to get a user verified fact but you don’t want the user to be blocked on the registration form, you can use this approach to continue with the execution line, and process the response as soon as it gets back.
Let’s see how we can request a verified email address with a non-blocking request.
def get_email_in_background(selfid) @client.facts.request(user, [:email_address]) do |res| return &quot;&quot; unless res.accepted? return res.attestation_values_for(:email_address).first # Refer to Receiving fact response - Deal with request for more info end rescue =&gt; e # An exception will be raised in case of a timeout or internal error return &quot;&quot; end // Use goroutines to manage this scenario // Use async() = {} to manage this scenario Asynchronous The asynchronous approach can be used in scenarios like the previous one, however it has a subtle difference, you have a single observer for all information requests, which can be useful in some situations as you can have all the logic centralized on a single point.
cid = @client.facts.request(selfid, [SelfSDK::FACT_EMAIL], async: true) resp, err := client.FactService().RequestAsync(&amp;fact.FactRequestAsync{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, CID: &quot;conversation_id&quot;, }) let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }], { async: true }) </p><p></p>`,url:"https://docs.joinself.com/sdk/facts/request/"},{value:"Sandbox",label:`<p>The Self Sandbox environment is a space where software developers and users can experiment with code and applications in an isolated setting with access to all the features of Self.
This environment provides a safe place to try new things, test and debug code, and explore new ideas without affecting the live production environment.
Get your mobile client Download the Sandbox app Follow the instructions on the mobile client to signup for a new account. Once you have completed the signup process you will need to verify an email address in the mobile client under Profile &gt; Contact Details.
Login to the Sandbox Developer Portal Now you can go to the Sandbox Developer Portal and login. Once you are logged in you can create your first publisher and then your first application.
You can refer to App setup section for more information on the configuration options you have for publishers and applications.
Limitations The Self Sandbox environment is for testing, and is not suitable for production use. The Sandbox environment provides reduced perfomance and resiliency, and we periodically purge the data.
</p>`,url:"https://docs.joinself.com/quickstart/sandbox/"},{value:"Blocking requests",label:`<p>facts = [{ sources: [SelfSDK::SOURCE_USER_SPECIFIED], fact: SelfSDK::FACT_EMAIL, operator: '==', expected_value: 'test@test.org' }] res = @client.facts.request_via_intermediary(selfid, facts) # GOTO Receiving fact response - Deal with the response req := fact.IntermediaryFactRequest{ SelfID: selfID, Intermediary: intermediary, Description: &quot;info&quot;, Facts: []fact.Fact{ { Fact: fact.FactDateOfBirth, Sources: []string{fact.SourceUserSpecified}, Operator: &quot;&gt;=&quot;, ExpectedValue: time.Now().Format(time.RFC3339), }, }, Expiry: time.Minute * 5, } resp, err := client.FactService().RequestViaIntermediary(&amp;req) try { let res = await sdk.facts().requestViaIntermediary(selfID, [{ fact: 'phone_number', operator: '==', sources: ['user_specified'], expected_value: '+44111222333' }]) if(!res) { sdk.logger.warn(\`fact request has timed out\`) } else if(res.status === &quot;unauthorized&quot;) { sdk.logger.warn(&quot;you are unauthorized to run this action&quot;) } else if (res.status === 'accepted') { sdk.logger.info(&quot;your assertion is....&quot;) sdk.logger.info(res.attestationValuesFor('phone_number')[0]) } else { sdk.logger.info(&quot;your request has been rejected&quot;) } } catch (error) { sdk.logger.error(error.toString()) } </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>blocking</p>`,url:"https://docs.joinself.com/sdk/zero/blocking/"},{value:"Send and receive messages",label:`<p>Self SDK allows you to send messages to any identity on self network, this includes users, orgs and apps.
The interface used to interact with messaging is chat service, let&rsquo;s see how can we create an app automatically responding all ping messages with a pong.
@app.chat.on_message do |msg| if msg.body == &quot;ping msg.message &quot;pong&quot; end end @app.chat.message user, &quot;ready!&quot; client.ChatService().OnMessage(func(cm *chat.Message) { if cm.Body == &quot;ping&quot; { cm.Message(&quot;pong&quot;) } }) @app.chat.message user, &quot;ready!&quot; sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { if (cm.body == &quot;ping&quot;) { cm.message(&quot;pong&quot;) } }) @app.chat.message user, &quot;ready!&quot; Easy, isn&rsquo;t it? As you can see, you can use the chat service message method to send messages to a specific user, and on_message to receive them.
The object representing a message has also some handy methods to interact with that message, included sending a new message to the same conversation with message(body).
Let&rsquo;s have a closer look at all the options you have when sending and receiving messages
Sending messages The interface for sending a normal message is quite simple, just provide the user and text you want to send and that&rsquo;s it.
However, the system provides some useful options you can pass to this method. Let&rsquo;s have a look at the most important ones.
@app.chat.message user, &quot;ready!&quot;, gid: &quot;group_id&quot;, rid: &quot;uuid&quot;, client.ChatService().Message(user, &quot;ready!&quot;, chat.MessageOptions{ GID: &quot;group_id&quot;, RID: &quot;uuid&quot;, }) client.chat().message user, &quot;ready!&quot;, { &quot;gid&quot;: &quot;group_id&quot;, &quot;rid&quot;: &quot;uuid&quot; } gid You&rsquo;ll see gid option supported across different methods, gid refers to group id, and when provided will indicate the other client the current conversation is a group conversation instead of a 1 to 1 chat.
Usually this id is not used directly through this method, and instead the message is sent through a helper on Group object, check Groups for more details.
rid In this case rid is used to refer a previous message by it&rsquo;s jti, once the other party receives a rid as part of the payload it will interpret is a direct response to a specific message, and it will be displayed accordingly.
If you&rsquo;ve already received a message you want to respond, you can do it directly through the respond method like:
@app.chat.on_message do |msg| msg.respond &quot;I like this&quot; end client.ChatService().OnMessage(func(cm *chat.Message) { cm.Respond(&quot;I like this&quot;) }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.respond(&quot;I like this&quot;) }) </p><p>messaging</p><p>message</p><p>messages</p>`,url:"https://docs.joinself.com/sdk/messaging/text-messages/"},{value:"App setup",label:`<p>Now that you have logged into the Sandbox Developer Portal you are ready to create your first publisher and application.
Create a publisher To create a publisher you need to provide a name and an image for your publisher. These will be displayed to users of the Self Sandbox network.
The next step is to generate keys for your publisher. The generated keys will only be displayed once so please copy the keys and store them somewhere safe.
Create an application After you store your publisher keys somewhere safe you can create your application. Please provide a name and an image for your application. These will be displayed to users of the Self Sandbox network.
You can also decide who can connect to you application. The default setting is everyone and we recommend you leave it like that, however you can restrict access to your Self ID only if you need to.
The next step is to generate keys for your application. The generated keys will only be displayed once so please copy the keys and store them somewhere safe.
There are a number of options you can toggle on/off after you create your application:
List your app on the Self Directory: This makes it easy for users to find your application. We recommend you enable this. Allow your app to receive messages: You should enable this if you want to support chat messaging with your application. Allow your app to receive calls: You should enable this if you want to support incoming voice calls with your application. Congratulations! You are now ready to start using your new application.
</p>`,url:"https://docs.joinself.com/quickstart/app-setup/"},{value:"Connections",label:`<p>This feature allows you to manage your connections by permitting and revoking incoming messages from specific identities.
During the app creation process you can define if your app permits connections from everyone, or just you. You can tweak this behaviour as shown below.
</p>`,url:"https://docs.joinself.com/sdk/users/"},{value:"Getting started",label:`<p>Requirements To build an app on self-network its required to have our app installed so you can log in to the Self Developer Portal.
Please visit the official app stores to download our official apps for Android and iOS
Create an account Visit Self Developer Portal and follow the steps to register. You&rsquo;ll need a Self Identifier account to proceed.
App creation Self-apps are autonomous self identities able to interact with other identities on the Self-network.
A developer can create an app through the developer portal. This app will be identified by a SELF_APP_ID and a SELF_APP_DEVICE_SECRET.
SELF_APP_ID is your public identifier on the network and you can share it with other peers. You must keep SELF_APP_DEVICE_SECRET in a secure place.
You’ll see below how to use these two strings to initialize your client and start interacting with the Self-network.
Remember — copy and store SELF_APP_DEVICE_SECRET, as we don&rsquo;t have access to it.
Environments Self provides a sandbox so you can try your app code before moving to production. You can register for a free developer account and create new test apps on the Sandbox developer portal here.
Once your app is ready you can create a new one on production here
</p><p>setup</p><p>configuration</p><p>requirements</p>`,url:"https://docs.joinself.com/sdk/setup/getting-started/"},{value:"Identity types",label:`<p>Self network is formed of different entities with the ability to interact between them.
We name these entities identities and they own a self_id, an array of device ids and an array of public keys.
An identity can only communicate with another identity if IdentityA is a connection of IdentityB. If this connection is in place IdentityA will be able to request the IdentityB properties (device_ids and public keys) to interact with it.
At the moment identities can be divided into users and apps.
Getting the public keys Every single identity on the Self network has at least one public key assigned to it. Lets see how you can get the public keys related to a Self user.
@user = @client.identity.public_key &quot;1112223334&quot;, &quot;1&quot; identity, _ := client.IdentityService().GetPublicKey(&quot;1112223334&quot;, &quot;1&quot;) let key = await client.identity().publicKey(&quot;1112223334&quot;, &quot;1&quot;) Identity devices Same as with public keys each identity has at least one device.
@devices = @client.identity.devices &quot;1112223334&quot; devices _ := client.IdentityService().GetDevices(&quot;1112223334&quot;) let devices = await client.identity().devices(&quot;1112223334&quot;) </p><p>identity</p><p>app</p><p>public keys</p><p>devices</p>`,url:"https://docs.joinself.com/sdk/users/identity-types/"},{value:"Modifiers",label:`<p>Async We&rsquo;ve already covered this modifier on the Asynchronous authentication requests.
It basically allows you to send an authentication request and ignore any responses.
This is usually used in combination with an Authentication response subscription
This modifier accepts a boolean. cid = @client.authentication.request(&quot;1112223334&quot;, async: true)// Given the language nature this modifier is not implemented on Go.let res = await client.authentication().request(&quot;1112223334&quot;, { 'async': true })CID Providing a cid allows you to override the randomly generated conversation id with your own, this is useful to keep track of conversations with a preset identifier, let’s see the asynchronous example using a custom cid.
Instead of using the randomly generated conversation identifier, we can force the system to use our own unique id.
@client.authentication.request(&quot;1112223334&quot;, cid: &quot;conversation_id&quot;)client.AuthenticationService().RequestAsync(&quot;1112223334&quot;, &quot;conversation_id&quot;)let res = await client.authentication().request(&quot;1112223334&quot;, { 'cid': &quot;conversation_id&quot; })Expiration timeout Providing exp_timeout parameter permits modify the default expiration timeout of an authentication request, making it only valid for a custom time.
Its provided as an integer with the total amount of seconds you want to be valid.
@client.authentication.request(&quot;1112223334&quot;, exp_timeout: 20000)// Not supported// Not supported</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/modifiers/"},{value:"Modifiers",label:`<p>A fact request accepts some modifiers for example
CID Passing the cid or conversation id, you&rsquo;ll be able to modify the default random uuid for that request, and easily identify the related response.
exp_timeout Timeout in seconds after which the request will expire. Useful if you want your fact request to be valid just for a specific period of time. It defaults to 900 seconds.
allowed_for Providing this option with a number of seconds, your app will be allowed to request the same data without user confirmation for the specified time.
This is quite useful if you intend to use some data recurrently but don&rsquo;t want to store it on your end.
Note this option is not compatible with auth modifier for security reasons.
auth Boolean representing if you want to display this fact request as an authentication with facts or not, it will default to false.
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>modifiers</p><p>options</p>`,url:"https://docs.joinself.com/sdk/facts/modifiers/"},{value:"System dependencies",label:"<p>Self SDK depends on some native libraries to manage encryption libself_olm and libself_omemo. Below you&rsquo;ll find the instructions to get them working on your system.\nDebian/Ubuntu $ curl -O https://download.joinself.com/olm/libself-olm_0.1.17_amd64.deb $ curl -O https://download.joinself.com/omemo/libself-omemo_0.1.2_amd64.deb $ apt install libsodium-dev $ apt install ./libself-olm_0.1.17_amd64.deb ./libself-omemo_0.1.2_amd64.deb Redhat/Centos $ rpm -Uvh https://download.joinself.com/olm/libself-olm-0.1.14-1.x86_64.rpm $ rpm -Uvh https://download.joinself.com/omemo/libself-omemo-0.1.2-1.x86_64.rpm Mac (x86_64) $ brew tap joinself/crypto $ brew install libself-olm libself-omemo Mac (m1/arm64) Brew on M1 macs currently lacks environment variables needed for the sdk to find the olm and omemo libraries, so you will need to add some additional configuration to your system:\nIn your ~/.zshrc, add:\nexport C_INCLUDE_PATH=/opt/homebrew/include/ export LIBRARY_PATH=$LIBRARY_PATH:/opt/homebrew/lib You should then be able to run:\n$ source ~/.zshrc $ brew tap joinself/crypto $ brew install --build-from-source libself-olm libself-omemo Note, you may also need to create /usr/local/lib if it does not exist:\n$ sudo mkdir /usr/local/lib </p><p>setup</p><p>configuration</p><p>requirements</p>",url:"https://docs.joinself.com/sdk/setup/dependencies/"},{value:"Message actions",label:`<p>In this section we will review what actions we can take to modify the message state.
Mark as received When your app receives a message the sdk is marking it as received by default. This behavior can be changed by modifying passing a specific parameter to on_message, at the same time you can mark a message as read on your convenience, let&rsquo;s see how.
@app.chat.on_message mark_as_delivered: false do |msg| msg.mark_as_delivered # explicitly mark the message as delivered end client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsDelivered() }, chat.OnMessageOptions{ MarkAsDelivered: false }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.markAsDelivered() }, { 'mark_as_delivered': false }) Default behavior for on_message is to mark the message as received as soon as it&rsquo;s received.
Mark as read Similarly to the previous example, you can modify on_message to automatically mark all messages as read with a specific option.
@app.chat.on_message mark_as_read: true do |msg| # ... end client.ChatService().OnMessage(func(cm *chat.Message) { // ... }, chat.OnMessageOptions{ MarkAsRead: true }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { // ... }, { 'mark_as_read': true }) Additionally you can explicitly mark a received message as read with your own logic.
@app.chat.on_message do |msg| msg.mark_as_read end client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsRead() }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.MarkAsRead() }) Edit For a message you&rsquo;ve already sent you can modify its body.
m = @app.chat.message user, &quot;one&quot; m.edit &quot;two&quot; m := @app.chat.message user, &quot;one&quot; m.Edit(&quot;two&quot;) let m = @app.chat.message user, &quot;one&quot; m.Edit(&quot;two&quot;) You&rsquo;re only allowed to modify your own messages.
Delete Deleting a message is as simple as modifying it, but using delete method instead.
m = @app.chat.message user, &quot;one&quot; m.delete m := @app.chat.message user, &quot;one&quot; m.Delete() let m = @app.chat.message user, &quot;one&quot; m.Delete() You&rsquo;re only allowed to delete your own messages.
</p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>`,url:"https://docs.joinself.com/sdk/messaging/actions/"},{value:"Non-blocking requests",label:`<p>@client.facts.request_via_intermediary(selfid, facts) do |res| # GOTO Receiving fact response - Deal with the response end // use language built in goroutines go func() { // ... } // use language built in async async() =&gt; { // ... } </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>non-blocking</p>`,url:"https://docs.joinself.com/sdk/zero/non-blocking/"},{value:"Authentication",label:`<p>Self provides an easy to implement Multi-factor and Biometric Authentication System, which ensures a higher level of security for your applications. The Self Authentication System allows for seamless integration of biometric authentication without the need for passwords or codes, verifying users directly from their phones.
Features Biometric authentication: Verifies users through unique biometric identifiers, such as fingerprints or facial recognition.
Privacy-focused: Authenticates users by their Self Identifier without storing any other personal information.
Easy integration: Simple implementation of authentication workflow using the Self SDKs.
Workflow A user enters their Self Identifier (ID) within your application. Your application requests authentication using the user&rsquo;s ID. The user receives an authentication request on their phone, which may require biometric verification (e.g., fingerprint or facial recognition). If the user successfully accepts the authentication request you&rsquo;ll be able to grant the current user Implementation Example The following example demonstrates how to implement an authentication workflow using the Self Ruby SDKs.
user = &quot;1112223334&quot;authenticated = @app.authentication.request(user).accepted?user := &quot;1112223334&quot;if resp, err != client.AuthenticationService().Request(user); err != nil {println(&quot;authentication rejected&quot;)return}authenticated := resp.Acceptedlet res = await client.authentication().request(&quot;1112223334&quot;)let authenticated = res.isAccepted()Steps to Implement the Authentication System Integrate the Self SDKs into your application. Allow users to enter their Self Identifier (ID) within your application. Request authentication by calling the authentication.request() method, passing the user&rsquo;s ID as an argument. Check if the authentication is accepted by evaluating the accepted? method. Benefits Enhanced security: Multi-factor and biometric authentication provides an additional layer of security for your applications, making it more difficult for unauthorized users to gain access.
Improved user experience: Users no longer need to remember complex passwords or codes, as authentication is handled through Self identifiers.
Privacy-focused: The system verifies users by their ID without storing any other personal information, reducing the risk of data breaches.
Conclusion The Multi-Factor and Biometric Authentication System offers an effective and secure way to authenticate users for your applications.
By implementing this system, you can offer your users a more convenient and secure authentication experience, while also protecting their privacy.
</p>`,url:"https://docs.joinself.com/sdk/authentication/"},{value:"Response",label:`<p>Subscribe Users can respond to authentication requests by accepting or rejecting them. On the other hand, you won’t receive asynchronous notifications for requests which have timed out.
You can subscribe to authentication responses with this snippet
@client.authentication.subscribe do |auth_res|puts resp.statusendclient.MessagingService().Subscribe(&quot;identities.authenticate.req&quot;, func(m *messaging.Message)) {// manage the response}client.messaging().subscribe(&quot;identities.authenticate.req&quot;, (res: any): any =&gt; {// manage the response})Processing the response if resp.accepted?p &quot;accepted&quot;elsif resp.rejected?p &quot;rejected&quot;elsif resp.unauthorized?p &quot;unauthorized&quot;elsif resp.errored?p &quot;errored&quot;elsep &quot;unkonwn status&quot;end// Or simply access the status string p resp.status // Go SDK will return an error for unsuccessful// responseserr = authService.Request(&quot;1112223334&quot;)if err != nil {log.Fatal(&quot;auth returned with: &quot;, err)}log.Println(&quot;authentication succeeded&quot;) try {let res = await client.authentication().request(&quot;1112223334&quot;)if(res.isAccepted() == true) {client.logger.info(\`\${res.selfID} is now authenticated 🤘\`)} else if(res.accepted == false) {client.logger.warn(\`\${res.selfID} has rejected your authentication request\`)} else {client.logger.error(res.errorMessage)}} catch (error) {client.logger.error(error.toString())}The interesting field in an authentication response is status. Valid values for status are:
accepted The user has accepted the authentication request, so you can proceed authenticating it on your app.
rejected The user has rejected the authentication request.
unauthorized You’re unauthorized to interact with this user, let it know it needs to be connected to your app before continuing with an authentication process.
errored An internal error happened.
Depending on the SDK there are different ways you can deal with different status, see some examples below
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/response/"},{value:"Response",label:`<p>Subscribe As the user also has the option to accept or reject a fact request, the response also comes with a status property and some helpers like the authentication response.
Additionally a fact response comes with a list of attestations for the requested fact.
Subscribing to a facts response is similar to authentication.
@client.facts.subscribe do |resp|# GOTO Deal with the response for detailsend// TBDsdk.facts().subscribe((res: any): any =&gt; {// GOTO Deal with the response for details})Processing fact response The fact response will comes with a status and the same list of helpers as we described on authentication to deal with it.
Additionally each fact of the response has a list of attestations let’s see how to process them.
resp.facts.each do |fact|p fact.namefact.attestations do |a|p &quot;received #{a.value} from #{a.source}/#{a.fact} signed by #{a.origin}&quot;endendfor _, f := range resp.Facts {log.Println(f.Fact, &quot;:&quot;, f.AttestedValues())}sdk.logger.info(res.attestationValuesFor('phone_number')[0])</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>`,url:"https://docs.joinself.com/sdk/facts/response/"},{value:"Asynchronous",label:`<p>res = @client.facts.request_via_intermediary(selfid, facts, async: true) req := fact.IntermediaryFactRequest{ SelfID: os.Args[1], Intermediary: intermediary, Description: &quot;info&quot;, Facts: []fact.Fact{ { Fact: fact.FactEmail, Sources: []string{fact.SourceUserSpecified}, Operator: &quot;==&quot;, ExpectedValue: &quot;test@example.com&quot;, }, }, Expiry: time.Minute * 5, } factService := client.FactService()
resp, err := factService.RequestViaIntermediary(&amp;req) if err != nil { log.Fatal(&quot;fact request returned with: &quot;, err) }
for _, f := range resp.Facts { if f.Result() != true { log.Fatal(&quot;intermediary could not verify the required facts&quot;) } log.Printf(&quot;Your assertion that %s %s is %t\\n&quot;, f.Fact, f.Operator, f.Result()) } let res = await sdk.facts().requestViaIntermediary(selfID, facts, { 'async': true } This will return a conversation id identifying the fact request conversation, you should store it and catch it on a subscription, as described on the next section.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>async</p>`,url:"https://docs.joinself.com/sdk/zero/async/"},{value:"Group management",label:`<p>Managing group conversations is something really simple with Self SDK, let&rsquo;s see an end to end example to understand how they work.
@groups = {} @app.chat.on_invite do |group| @groups[group.gid] = group group.join group.message(&quot;hi&quot;) end @app.chat.on_join do |msg| @groups[msg[:gid]].members &lt;&lt; msg[:iss] end @app.chat.on_leave do |msg| @groups[msg[:gid]].members.delete(msg[:iss]) end @app.chat.on_message do |msg| return if msg.gid.nil? puts &quot;[#{@groups[msg.gid].name}] #{msg.from}: #{msg.body}&quot; end groups := make(map[string]*chat.Group, 0) chat.ChatService().OnInvite(func(g *chat.Group) { g.Join() groups[g.GID] = g g.Message(&quot;hey!&quot;) }) cs.OnLeave(func(iss, gid string) { delete(groups, gid) }) chat.ChatService().OnJoin(func(iss, gid string) { if _, ok := groups[gid]; ok { groups[gid].Members = append(groups[gid].Members, iss) } }) chat.ChatService().OnMessage(func(cm *chat.Message) { if len(cm.GID) == 0 { return } fmt.Printf(&quot;[%s] %s: %s&quot;, groups[cm.GID].Name, cm.Iss, cm.Body) }) let groups = {} sdk.chat().onInvite(async (g: ChatGroup) =&gt; { g.join() groups[g.gid] = g await groups[g.gid].message(&quot;hey!&quot;) }) sdk.chat().onJoin(async (iss: string, gid: string) =&gt; { groups[gid].members.push(iss) }) sdk.chat().onLeave(async (iss: string, gid: string) =&gt; { delete groups[gid].members[iss] }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { if (len(cm.gid) &gt; 0) { console.log(\`[\${groups[cm.gid].name}] \${cm.iss}: \${cm.body}\`) } }) As you can see this example manages every group incoming message, to keep an in memory updated list of groups with its members.
Creating a group Your app is als also able to create a group by calling invite method. members = [user1, user2, user3] @app.chat.invite &quot;my_gid&quot;, &quot;Group name&quot;, members members = []string{user1, user2, user3} client.ChatService().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members) let members = [user1, user2, user3] sdk.chat().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members) Have in mind you can send messages to a newly created group, but those messages will only be delivered to the group members that have decided to join the group.
Groups can also have an image as avatar, you can pass a file contents as parameter to chat invite to provide that image. members = [user1, user2, user3] URI.open(&quot;https://www.avasflowers.net/img/prod_img/avasflowers-dreaming-of-tuscany-bouquet.jpg&quot;) do |image| @groups[gid] = @app.chat.invite(gid, &quot;MagicGroup&quot;, members, { data: image.read, mime: &quot;image/jpg&quot; }) end members = []string{user1, user2, user3} data, err := os.ReadFile(&quot;/tmp/dat&quot;) check(err) client.ChatService().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members, chat.InviteOptions{ Data: data, Mime: &quot;image.gif&quot;, }) import * as fs from 'fs'; let data = fs.readFileSync('foo.txt','utf8'); let members = [user1, user2, user3] sdk.chat().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members, { &quot;data&quot;: data, &quot;mime&quot;: &quot;image/gif&quot;, }) Messaging and groups Sending messages to a group is as easy as calling the message method on that group. Additionally once you receive a message on a group you will have access to all its helpers to continue the conversation without having to care about the group itself.
</p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>`,url:"https://docs.joinself.com/sdk/messaging/groups/"},{value:"Initializing your client",label:`<p>Install your client $ gem install &quot;selfsdk&quot; $ go get github.com/joinself/self-go-sdk $ npm install self-sdk We currently offer support for some basic clients. We are always happy to receive contributions to review - send us a PR, or contact us at info@joinself.com to share what you have built with us!
Language URL Go https://github.com/joinself/self-go-sdk Ruby https://github.com/joinself/self-ruby-sdk/ Typescript https://github.com/joinself/self-typescript-sdk/ Referencing the SDK SelfSDK is referenced like any other library for each specific language.
require &quot;selfsdk&quot; import &quot;github.com/joinself/self-go-sdk&quot; const SelfSDK = require(&quot;self-sdk&quot;); Storage key generation Self-SDK locally persists session and account information needed for end to end encryption. A SELF_STORAGE_KEY is required to securely encrypt this information. It is recommended that you use a large random string for your SELF_STORAGE_KEY. You can generate a random string through the command line with:
$ LC_ALL=C tr -dc '[:alnum:]' &lt; /dev/urandom | head -c64
Keep that key in a secure place as you’ll need it to initialize a connection.
Basic connection A basic connection to Self network only requires your SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR.
You may want to add SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR as environment variables.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;]) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), Custom environment When you’re debugging your app, you may want to point to the sandbox environment instead of production to run your tests. You can define the environment by passing additional parameters to the Self client initialization.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;], env: :sandbox) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), Environment:	&quot;sandbox&quot;, }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), { 'env': 'sandbox' }) Reconnection Self-SDK keeps a websocket connection open to self-messaging, but eventually, that connection may drop. By default Self-SDK will try to reconnect, but you can override this behaviour by passing custom parameters to initialization.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;], auto_reconnect: false) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), ReconnectAttempts:	-1, }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), { 'autoReconnect': false }) </p><p>install</p><p>setup</p><p>initialisation</p>`,url:"https://docs.joinself.com/sdk/setup/initialize/"},{value:"Starting the client",label:`<p>Starting your client At this point you may have your client setup, but it&rsquo;s not yet ready or connected to self network.
In order to be able to send an receive messages from the Self Network you&rsquo;ll need to call start on your client.
@client.start client.Start() client.start() A separated approach for initialize and start your client allows you to subscribe to certain events before the connection has started, and avoid missing some incoming messages.
</p><p>install</p><p>setup</p><p>start</p>`,url:"https://docs.joinself.com/sdk/setup/start/"},{value:"Glossary",label:`<p>Other Self terminology &nbsp
ACL - Access Control List An access control list (ACL) is a list of permissions attached to an object. An ACL specifies which users or system processes are granted access to objects, as well as what operations are allowed on given objects. Each entry in a typical ACL specifies a subject and an operation.
&nbsp
AISP - Account Information Service Provider Account Information Service Provider (AISP) lets you see all of your account information from different bank accounts in one place online or in a mobile app. AISPs can include budgeting apps and price comparison websites offering budgeting help and product recommendations. An AISP needs your explicit consent to provide you with these services.
&nbsp
AML - Anti Money Laundering Refers to all policies and pieces of legislation that force financial institutions to proactively monitor their clients in order to prevent money laundering and corruption.
&nbsp
API - Application Programming Interface API (application programming interface) is a set of subroutine definitions, communication protocols, and tools for building software. In general terms, it is a set of clearly defined methods of communication among various components. &nbsp
Attestation The act of an individual or organisational SelfID to attest / confirm / authenticate / validate / prove true another individual or organisational SelfIDs claim. &nbsp
Aure Self’s native token, used for paying for transactions on Self Blockchain A growing list of records, called blocks, which are linked using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data (generally represented as a merkle tree root hash). a blockchain is typically managed by a peer-to-peer network collectively adhering to a protocol for inter-node communication and validating new blocks. Once recorded, the data in any given block cannot be altered retroactively without alteration of all subsequent blocks, which requires consensus of the network majority. &nbsp
Certificate Authority A Certificate Authority (CA) is an entity that issues digital certificates. Claim A declaration by an individual or organisational SeflID of some information about itself, or an asset it owns, that is sent to one or more other individual or organisational SelfIDs to attest to. &nbsp
CLI - Command Line Interface A text-based interface that is used to operate software and operating systems while allowing the user to respond to visual prompts by typing single commands into the interface and receiving a reply in the same way. &nbsp
Cold Storage Cold storage is an offline wallet provided for storing cryptocurrencies. With cold storage, the digital wallet is stored on a platform that is not connected to the internet, thereby, protecting the wallet from unauthorised access, cyber hacks, and other vulnerabilities that a system connected to the internet is susceptible to. &nbsp
DID - Decentralised Identifier Decentralised Identifiers (DIDs) are a new type of identifier for verifiable, "self-sovereign" digital identity. DIDs are fully under the control of the DID subject, independent from any centralised registry, identity provider, or certificate authority. DIDs are URLs that relate a DID subject to means for trustable interactions with that subject. DIDs resolve to DID Documents — simple documents that describe how to use that specific DID. Each DID Document contains at least three things: cryptographic material, authentication suites, and service endpoints. Cryptographic material combined with authentication suites provide a set of mechanisms to authenticate as the DID subject (e.g., public keys, pseudonymous biometric protocols, etc.). Service endpoints enable trusted interactions with the DID subject. &nbsp
Digital Certificate The digital certificate also known as public key certificate, or identity certificate certifies the ownership of a public key by the named subject of the certificate. This allows others (relying parties) to rely upon signatures or assertions made by the private key that corresponds to the public key that is certified. &nbsp
DLT - Distributed Ledger Technology A distributed ledger is a database that is consensually shared and synchronised across network spread across multiple sites, institutions or geographies. It allows transactions to have public "witnesses," thereby making a cyberattack more difficult. The participant at each node of the network can access the recordings shared across that network and can own an identical copy of it. Further, any changes or additions made to the ledger are reflected and copied to all participants in a matter of seconds or minutes. &nbsp
DRI - Directly Responsible Individual Directly Responsible Individual relates to the person who is allocated as the owner of an Epic or a specific task. &nbsp
DUNS Number The DUNS number is a nine-digit number, issued and regulated by D&B (Dun & Bradstreet - a company that provides commercial data, analytics, and insights for businesses). It is assigned to a single business entity, having a unique, separate, and distinct operation for the purpose of identifying them. &nbsp
E2E - End-to-end End to End encryptions allows only the users communicating can read the messages. &nbsp
Epic Epics represent the specific tasks or a body of work that can be broken down into use cases. Milestones consist of a number of Epics to be completed. &nbsp
FCA - Financial Conduct Authority The Financial Conduct Authority is a financial regulatory body in the United Kingdom, but operates independently of the UK Government. &nbsp
Hash Encoding of data in to a small and generally fixed size &nbsp
HLF - Hyperledger Fabric A Fabric permissioned blockchain network is a technical infrastructure that provides ledger services to application consumers and administrators. In most cases, multiple organisations come together as a consortium to form the network and their permissions are determined by a set of policies that are agreed to by the consortium when the network is originally configured. Moreover, network policies &nbsp
Horizon API Server Horizon is an API server for the Stellar ecosystem. It acts as the interface between stellar-core and applications that want to access the Stellar network. It allows you to submit transactions to the network, check the status of accounts, subscribe to event streams, etc. &nbsp
Hot Storage Hot storage is online wallet provided for storing cryptocurrencies. With hot storage, the digital wallet is stored on a platform that is connected to the internet. Differently from a cold storage, a hot storage is subjected to unauthorised access, cyber hacks, and other vulnerabilities that a system connected to the internet is susceptible to. &nbsp
Hyperledger Hyperledger is a multi-project open source collaborative effort hosted by The Linux Foundation. We are using it to store the self ID into a public key mapping, and potentially to store the SelfID score too. &nbsp
JWE - JSON Web Encryption JSON Web Encryption is an IETF standard providing a standardised syntax for the exchange of encrypted data, based on JSON and Base64. It forms part of the JavaScript Object Signing and Encryption (JOSE) suite of protocols. &nbsp
JWS - JSON Web Signature JSON Web Signature is an IETF proposed standard [RFC7515] for signing arbitrary data. JWS is a way to ensure integrity of information in a highly serialisable, machine-readable format. That means that it is information, along with proof that the information hasn't changed since being signed. It can be used for sending information from one web site to another, and is especially aimed at communications on the web. It even contains a compact form optimised for applications like URI query parameters. &nbsp
JWT - JSON Web Tokens JWT - JSON Web Tokens is a JSON-based open standard (RFC 7519) for creating access tokens that assert a certain number of claims. For example, a server could generate a token that has the claim "logged in as admin" and provide that to a client. The client could then use that token to prove that it is logged in as admin. &nbsp
K8S The container orchestration tool that hosts the Self platform. &nbsp
KYC - Know Your Customer Know your Customer (Client) checks allows businesses to verify the identity of their clients. Guidelines are often dictated by government or financial authorities such as the FCA. &nbsp
Node A node is a device on a blockchain network, that is in essence the foundation of the technology, allowing it to function and survive. The role of a node is to support the network by maintaining a copy of a blockchain and, in some cases, to process transactions. &nbsp
OAuth - Open Authorisation OAuth is a simple way to interact with private data, allowing third parties limited access to a web-service via access tokens at the authorisation of the account owner. &nbsp
Open Banking The use of open API’s to enable third parties access to details from an individual's bank account. &nbsp
Oracle An oracle, in the context of blockchains and smart contracts, is an agent that finds and verifies real-world occurrences and submits this information to a blockchain to be used by smart contracts. ... An oracle is a data feed – provided by third party service – designed for use in smart contracts on the blockchain. In the case of Self/Biler a good example is the Client Payment Oracle/Fiat Currency Gateway. This gets notified by webhook from the bank (ideally) of the deposit of fiat currency into a client money account, it then credits the deposited fiat funds with a corresponding tokenized form of the currency which can be controlled by a User’s private keys. &nbsp
P2P - Peer-to-peer Peer-to-peer computing is a distributed application architecture that partitions workloads between peers. &nbsp
PDS - Personal Data Store A platform where people can securely store, manage and share their data. &nbsp
PIFI - Personally Identifiable Financial Information Personally identifiable financial information (PIFI) is any type of personally identifiable information (PII) that is linked to that person's finances. A credit card number is a prime example of PIFI. &nbsp
PII - Personally Identifiable Information Personally identifiable information (PII) is any data that could potentially identify a specific individual. Any information that can be used to distinguish one person from another and can be used for de-anonymising anonymous data can be considered PII. PII can be sensitive or non-sensitive. Non-sensitive PII is information that can be transmitted in an unencrypted form without resulting in harm to the individual. Non-sensitive PII can be easily gathered from public records, phone books, corporate directories and websites.
Sensitive PII is information which, when disclosed, could result in harm to the individual whose privacy has been breached. Sensitive PII should, therefore, be encrypted in transit and when data is at rest. Such information includes biometric information, medical information, personally identifiable financial information (PIFI) and unique identifiers such as passport or Social Security numbers.
&nbsp
PISP - Payment Initiation Service Provider A Payment Initiation Service Provider (PISP) lets you pay companies directly from your bank account rather than using your debit or credit card through a third-party such as Visa or MasterCard. A PISP needs your explicit consent before providing you with this kind of service. &nbsp
PKI - Public Key Infrastructure A public key infrastructure (PKI) is a set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption. &nbsp
Ripple Ripple is a real-time gross settlement system, currency exchange and remittance network created by Ripple Labs Inc. that provides one frictionless experience to send money globally using the power of blockchain and the XRP token. &nbsp
SC - Smart Contract Smart contracts are self-executing contracts with the terms of the agreement between buyer and seller being directly written into lines of code. The code and the agreements contained therein exist across a distributed, decentralised blockchain network. A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Stablecoin/Stable Token
A stablecoin is a cryptocurrency designed to minimise the price volatility. Stablecoins are used as stores of value or units of account, as well as in other use cases where volatile cryptocurrencies may be less desirable. Authors of stablecoins use different designs to achieve price stability. The value of a stablecoin can be pegged to fiat currencies, or to exchange traded commodities (such as gold, silver, other precious and industrial metals, etc). Stablecoins can be centralised where they can be backed by fiat and exchange-traded commodities directly, or in a decentralised fashion via leveraging other cryptocurrency projects in different ways.
&nbsp
Stellar Stellar is an open-source, decentralised protocol for digital currency to fiat currency transfers which allows cross-border transactions between any pair of currencies using the XLM token. &nbsp
Token Crypto tokens are special kind of virtual currency tokens that reside on their own blockchains and represent an asset or utility. For example, one can have a crypto token that represents x number of customer loyalty points on a blockchain that is used to manage such details for a retail chain. &nbsp
TrustLine (Stellar/Ripple Specific) The Trustlines Network is the original Ripple idea built on Ethereum. The Trustlines Network targets the problem of fair access to money by implementing money as bilateral peer-to-peer issued blockchain-based credit. We are developing an open source protocol, including a mobile app empowering end-users to make global payments based on their existing trusted social network. &nbsp
UID - Unique Identifier A unique identifier (UID) is a numeric or alphanumeric string that is associated with a single entity within a given system. UIDs make it possible to address that entity so that it can be accessed and interacted with. &nbsp
Use Case Use Cases are a list of actions or event steps between a role and a system to achieve a goal, and typically consist of a set of possible scenarios between the two. &nbsp
Verifier The party who needs to trust a claim &nbsp
VoIP - Voice over IP Voice over Internet Protocol delivers voice communications over the internet, likely meaning it is lower cost. An example of this would be Skype. &nbsp
WOT - Web of Trust a web of trust is a concept used in PGP, GnuPG, and other OpenPGP-compatible systems to establish the authenticity of the binding between a public key and its owner. Its decentralised trust model is an alternative to the centralised trust model of a public key infrastructure (PKI), which relies exclusively on a certificate authority (or a hierarchy of such). As with computer networks, there are many independent webs of trust, and any user (through their identity certificate) can be a part of, and a link between, multiple webs. &nbsp
ZKP - Zero Knowledge Proofs A zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that something is true, without revealing any information apart from the fact that this specific statement is true. </p>`,url:"https://docs.joinself.com/quickstart/glossary/"},{value:"Facts",label:`<p>A Facts is a statement about an identity. Verified facts are facts that have been attested to by trusted issuer(s).
A single fact can be verified by multiple issuers and so have multiple assertions. Verified facts are held by identities and can be shared with other identities (relying parties) who require them.
Facts and related attestations are stored on the user’s device, so the user has full control over who can access its information.
Each fact has the following properties:
Sources A fact’s source represents where this fact comes from, for example a DOB can come from different sources such as a passport or a driving license. By default this field is set with a wildcard “*” and the user will select the source on their device. Same happens if you specify multiple sources.
At the moment there are three different sources user_specified, passport and driving_license.
As this list is always growing, you can check the possible values on your SDK ruby-sdk and go-sdk.
Fact This is the name of the fact you want to request like display_name, email_address or phone_number.
The list of values by source is:
user_specified: display_name, email_address and phone_number passport and _identity-card _: document_number, surname, given_names, date_of_birth, date_of_expiration, sex, nationality, _country_of_issuance. driving_license : document_number, surname, given_names, date_of_birth, date_of_issuance, date_of_expiration, address, issuing_authority, place_of_birth, country_of_issuance. Attestations A list of verified attestations signed by an issuer. This only has content on fact request responses, and it contains a list of attestations for the current fact.
Expected value When you send an intermediary fact check you expect the value of a user’s fact to be compared with an expected value, this field is where you will provide that value.
Operator On an intermediary fact check this field contains the operator used to compare the expected value against the expected value. Valid operators can be found here
Fact requests Fact requests allow your app to request specific facts from identities on the Self-network.
Only verified facts can be requested
The approaches to request facts are similar to authentication, so let&rsquo;s have a look at them.
By default fact requests will expire after 15 minutes, you can change this defaults with \`Expiry\` option.</p>`,url:"https://docs.joinself.com/sdk/facts/"},{value:"QR",label:`<p>Presenting users with a QR makes your authentication workflow more convenient for users on non-mobile devices.
The authentication workflow using QR codes allows users to authenticate on your project without handwriting its self identifier, just by scanning the QR code you&rsquo;re providing.
# Generate a QR code to authenticate @app.authentication .generate_qr .as_png(border: 0, size: 400) .save('/tmp/qr.png', :interlace =&gt; true) qrdata, err := s.auth.GenerateQRCode(&amp;authentication.QRAuthenticationRequest{ QRConfig: fact.QRConfig{ Size: 400, BackgroundColor: &quot;#FFFFFF&quot;, ForegroundColor: &quot;#000000&quot;, }, }) let buf = sdk.authentication().generateQR() const fs = require('fs').promises; await fs.writeFile('/tmp/qr.png', buf); Once the user scans the QR code with its device and accepts the authentication request, it will send back an authentication response to your app.
Have in mind the user&rsquo;s device will send you back an authentication response, so setup a subscription to that topic.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/qr/"},{value:"Attachments / objects",label:`<p>Sharing an image, a document or just a gif is an important part of your users daily messaging, the SDK allows your app to send this kind of messages as well. Let&rsquo;s see how.
Public objects Most of the time we only share public images, and in this case we don&rsquo;t require the document to be encrypted, so we can directly share the URL.
opts = { objects: [{ link: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, name: &quot;homer&quot;, mime: &quot;image/gif&quot;, }] } client.message user, &quot;ready!&quot;, opts obj := chat.MessageObject{ Name: &quot;Hello&quot;, Link: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, Mime: &quot;image/gif&quot;, } m, err = client.ChatService().Message([]string{os.Args[1]}, &quot;no way...&quot;, chat.MessageOptions{ Objects: []chat.MessageObject{obj}, }) opts = { &quot;objects&quot;: [{ &quot;link&quot;: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, &quot;name&quot;: &quot;homer&quot;, &quot;mime&quot;: &quot;image/gif&quot;, }]} client.chat().message user, &quot;ready!&quot;, opts) Non-public objects All non-public objects shared between identities are encrypted by default using Poly1305. This encryption layer is built on the SDK, so should be transparent for end users. Let&rsquo;s see how we can send a local file.
URI.open(path) do |image| name = &quot;image.#{path.split(&quot;.&quot;).last}&quot; mime = &quot;image/#{path.split(&quot;.&quot;).last}&quot; msg.message(&quot;your image sir...&quot;, objects: [{ name: name, data: image.read, mime: mime }]) end data, err := os.ReadFile(&quot;/tmp/dat&quot;) check(err) m, err = cs.Message([]string{os.Args[1]}, &quot;your file sir...&quot;, chat.MessageOptions{ Objects: []chat.MessageObject{chat.MessageObject{ Name: &quot;image.gif&quot;, Data: data, Mime: &quot;image/gif&quot;, }}, }) import * as fs from 'fs'; let data = fs.readFileSync('foo.txt','utf8'); client.chat().message user, &quot;your file sir...&quot;, { &quot;objects&quot;: [{ &quot;data&quot;: data, &quot;name&quot;: &quot;image.gif&quot;, &quot;mime&quot;: &quot;image/gif&quot;, }]}) </p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>object</p><p>image</p><p>file</p>`,url:"https://docs.joinself.com/sdk/messaging/objects/"},{value:"Subscribe to zero knowledge fact check",label:`<p>A subscription to an intermediary fact check response behaves exactly the same as a basic fact response.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>subscribe</p>`,url:"https://docs.joinself.com/sdk/zero/subscribe/"},{value:"Disconnecting",label:`<p>You should gracefully manage the client disconnection by calling close method. If a connection is not gracefully closed Self messaging servers will kill that connection after one minute.
@client.close client.Close() client.close() </p><p>setup</p><p>disconnecting</p><p>shut down</p><p>stop</p><p>close</p>`,url:"https://docs.joinself.com/sdk/setup/disconnect/"},{value:"Custom",label:`<p>Self Core Facts are useful for general purpose, but the process of adding new core facts is slow and not flexible enough to support app custom facts.
Custom facts will allow you to:
Create custom facts. Store facts on the user&rsquo;s device. Consume custom facts. Share custom facts with other apps. Interact with other apps on the Self ecosystem. All this is basically accomplished by using the user&rsquo;s device as secure storage for critical information.
Issuing facts Groups Facts are presented to the user in groups. Groups have name and icon properties.
param description required name The name of the group as it will be displayed to the user. true icon The icon to be displayed close to the group name false Self App supports all material UI icons, you can search all available icons on google fonts.
This is how we can create a group.
my_group = SelfSDK::Services::Facts::Group.new( &quot;Trip to Venice&quot;, &quot;airplanemode_active&quot; ) g := fact.FactGroup{ Name: &quot;Trip to Shangai&quot;, Icon: &quot;airplanemode_active&quot;, } let group = new Group(&quot;group name&quot;, &quot;plane&quot;) Facts Facts are composed of a key, a value and a source.
param description required key is the id for the fact, it will allow other apps to request your facts by id. true value It&rsquo;s stored as a string by default true source it groups facts from the same source, it allows other apps to use it as filters. true group if group is not provided facts will end under on the ungrouped section on the user&rsquo;s device false type it defines how the fact has to be processed by other clients, it defaults to string, but can also be set as password or delegation_certificate false my_fact = SelfSDK::Services::Facts::Fact.new( &quot;confirmation_code&quot;, &quot;CD128763&quot;, &quot;source12&quot;, group: my_group) f := fact.FactToIssue{ Key: &quot;BCN-SIN-cc&quot;, Value: &quot;CD128763&quot;, Source: source, Group: &amp;g, } let fact = new FactToIssue(&quot;foo&quot;, &quot;bar&quot;, source, { group: group }) Issuing facts Once you have your fact defined, it&rsquo;s time to send it to your user&rsquo;s device. You can do this by calling issue method on the facts service.
param description required user the user you&rsquo;re signing and sending facts to true facts an array with the facts you want to issue true viewers an array of app identifiers related to apps apps that can consume this facts false @app.facts.issue(user, my_fact], viewers: [appID1, appID2]) client.FactService().Issue(selfid, []fact.FactToIssue{f}, []string{}) await sdk.facts().issue(selfID, [fact]) Retrieving facts Retrieving facts is pretty much the same as we do for accessing core facts, the only difference is we must specify what issuers are we going to be accepting on our request, let&rsquo;s see an example.
myAppID = ENV[&quot;SELF_APP_ID&quot;] @app.facts.request(user, [{ fact: my_fact.key, issuers: [myAppID] }]) do |res| if res.status == &quot;rejected&quot; puts 'Information request rejected' exit! end k = my_fact.key.to_sym a = res.attestation_values_for(k) puts &quot;Your stored fact is #{a.first}!&quot; end resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfid, Description: &quot;We need access to your flight confirmation codes to reschedule your flights&quot;, Facts: []fact.Fact{ { Fact: f[0].Key, Sources: []string{source}, Issuers: []string{appID}, }, }, Expiry: time.Minute * 5, }) let res = await sdk.facts().request(selfID, [{ fact: fact.key, issuers: [ appID ] }]) Scope and facts Custom facts scope is configurable by the developer by using viewers and issuers parameters to facts.issue and facts.request. This makes it possible to create private, protected and public custom facts.
Private By specifying yourself as the only viewers on a facts.issue you will be creating facts you&rsquo;re the only one able to consume.
Protected Specifying multiple app ids as viewers you&rsquo;ll make those facts available only to a subset of apps.
Public When viewers parameter is not provided, issued facts become public.
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>custom</p>`,url:"https://docs.joinself.com/sdk/facts/custom/"},{value:"Dynamic link",label:`<p>When you&rsquo;re authenticating users on your platform straight on their mobile devices, is when dynamic links are more useful.
A dynamic link will authenticate a user on your platform by clicking a link and accepting the authentication request on his phone.
As part of this process, you have to share the generated link with your users, and wait for a response.
In order to use a dynamic link, you must generate a redirection code on the developer portal, once you have it you can use it to generate a url which you can share with your users.
url = @client.authentication.generate_deep_link(redirection_code) link, err := authService.GenerateDeepLink(&amp;authentication.DeepLinkAuthenticationRequest{ ConversationID: cid, Callback: redirectionCode, Expiry: time.Minute * 5, }) if err != nil { log.Fatal(&quot;auth returned with: &quot;, err) } let url = sdk.authentication().generateDeepLink(redirectionCode) Have in mind the user&rsquo;s device will send you back an authentication response, so setup a subscription to that topic.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/dynamic_link/"},{value:"Messaging",label:`<p>The Self SDK provides a comprehensive set of messaging capabilities, allowing developers to integrate secure and privacy-focused communication features into their applications.
With Self, you can enable end-to-end encrypted messaging between users, support group messaging, exchange encrypted attachments, and implement various message actions.
This documentation describes the features, functionalities, and implementation details of the Self SDK.
Implementation Example Simple ping-pong messaging example
@app.chat.on_message do |msg|if msg.body == &quot;pingmsg.message &quot;pong&quot;endend@app.chat.message user, &quot;ready!&quot;client.ChatService().OnMessage(func(cm *chat.Message) {if cm.Body == &quot;ping&quot; {cm.Message(&quot;pong&quot;)}})@app.chat.message user, &quot;ready!&quot;sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; {if (cm.body == &quot;ping&quot;) {cm.message(&quot;pong&quot;)}})@app.chat.message user, &quot;ready!&quot;Privacy-Focused The Self SDK prioritizes privacy by employing end-to-end encryption for all communications.
This ensures that only the sender and the intended recipient of the messages have access to the shared data.
The SDK implements industry-standard encryption algorithms and protocols, ensuring that sensitive user information remains secure and protected.
Easy Integration Implementing the Self SDK into your application is straightforward, enabling you to quickly enhance your communication capabilities.
The SDK provides a simple and intuitive API, allowing developers to seamlessly integrate messaging features into their existing codebase.
With comprehensive documentation and code examples, the integration process becomes smooth and hassle-free.
Text messages API
Group Messaging The Self SDK includes built-in support for group messaging, enabling users to participate in secure conversations with multiple participants.
Developers can easily create and manage groups, invite users, and facilitate encrypted messaging among group members.
The SDK&rsquo;s group messaging functionality ensures that communication within groups is private and protected.
Group management docs
Attachments With the Self SDK, you can enrich your messaging experience by exchanging encrypted chat objects such as documents, images, and other attachments.
The SDK provides a convenient interface for attaching files to messages, ensuring the secure transmission of sensitive information.
Whether it&rsquo;s sharing important documents or captivating images, the Self SDK allows users to exchange attachments with peace of mind.
Attachments docs
Message Actions The Self SDK offers a range of message actions that developers can implement to enhance the messaging experience.
These actions include marking messages as received or read, modifying message content, and deleting messages.
By implementing message actions, users can have more control over their conversations, ensuring that messages accurately reflect their communication status and preferences.
Conclusion The Self SDK empowers developers to integrate robust and privacy-focused messaging capabilities into their applications.
With end-to-end encryption, easy integration, group messaging support, attachment exchange, and flexible message actions, the SDK provides a comprehensive solution for secure communication.
By leveraging the Self SDK, developers can enhance their applications with privacy-focused messaging features, creating a secure and reliable communication platform for their users.
</p>`,url:"https://docs.joinself.com/sdk/messaging/"},{value:"Zero knowledge fact responses",label:`<p>This is similar to the fact request, the only difference in this case is that the attestation.value will always be a boolean indicating if your check is accomplished or not.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>response</p>`,url:"https://docs.joinself.com/sdk/zero/response/"},{value:"Notify",label:`<p>It prompts the user with a push notification or badge with a specific message. The message will be available on the notifications screen.
@client.messaging.notify &quot;1234567890&quot;, &quot;Hello world!&quot; err := client.MessagingService().Notify(&quot;1234567890&quot;, &quot;Hello world!&quot;) await sdk.messaging().notify(&quot;1234567890&quot;, &quot;Hello world!&quot;) </p><p>notify</p><p>notifications</p><p>push notification</p>`,url:"https://docs.joinself.com/sdk/notify/"},{value:"Recurrent requests",label:`<p>As we&rsquo;ve seen on Facts section you can request user&rsquo;s verified sensible data through facts service.
This becomes really useful when you can use the data at the moment. However, if you need to access the same data periodically or some time in the future, you&rsquo;ll be forced to store it.
Self recurrent requests feature allows you to access the same data for a specific period of time without having to wait for user&rsquo;s acceptance, so you don&rsquo;t need to store it on your servers.
Recurrent requests looks exactly the same as a regular fact request, except it makes use of allowed_for modifier, let&rsquo;s see an example.
ten_days = 10 * 60 * 60 * 60 # Request email, with recurrent requests enabled for ten days res = @client.facts.request(user, [:email_address], allowed_for: ten_days) # At this point the user will be prompted with a confirmation box to # allow access its email for the next 10 days. # # If we send the same request again, it will be automatically shared by the device # without user interaction. res = @client.facts.request(user, [:email_address]) // Request email, with recurrent requests enabled for ten days resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, AllowedFor: time.Day * 10, }) check(err) // At this point the user will be prompted with a confirmation box to // allow access its email for the next 10 days. // // If we send the same request again, it will be automatically shared by the device // without user interaction. resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, }) check(err) let tenDays = 10 * 60 * 60 * 60 // Request email, with recurrent requests enabled for ten days let res = await sdk.facts().request(user, [{ fact: &rsquo;email_address&rsquo;, allowed_for: tenDays }]) // At this point the user will be prompted with a confirmation box to // allow access its email for the next 10 days. // // If we send the same request again, it will be automatically shared by the device // without user interaction. let res = await sdk.facts().request(user, [{ fact: &rsquo;email_address&rsquo; }]) Given the user is always able to cancel this recurrent requests at any time, it&rsquo;s highly recommended to include the allowed for modifier on every request.
Even the responses to your fact requests are automated by the user, have in mind the request always hits the user&rsquo;s device, so the response can take some time to get back to you..
</p>`,url:"https://docs.joinself.com/sdk/facts/recurrent/"},{value:"Combined",label:`<p>Many times, specially on a registration process you want your users to authenticate and at the same time you require some sort of specific facts, for example name or email.
Facts service allows you to send a fact request with the form of an authentication, with the option auth
cid = @client.facts.request(selfid, [SelfSDK::FACT_EMAIL], async: true, auth: true)req := fact.FactRequestAsync{SelfID: selfID,Description: &quot;info&quot;,Facts: []fact.Fact{{ Fact: fact.FactEmail }},Expiry: time.Minute * 5,CID: &quot;conversation_id&quot;,Auth: true,}resp, err := client.FactService().RequestAsync(&amp;req) if err != nil { return &quot;&quot;, err } let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }], { async: true, auth: true })</p><p>auth</p><p>facts</p><p>request</p><p>registration</p>`,url:"https://docs.joinself.com/sdk/facts/combined/"},{value:"Zero-knowledge",label:`<p>An easy to use zero knowledge fact checker allows developers to ask the questions they really need an answer to, and receive anonymised answers.
That means they need to worry less about running a secure compliant environment.
How do they work? Intermediary fact checks are useful when you want to run a check of a user’s verified fact without having to gain access to that fact.
Eg. You want to verify a user is over 18, but you don’t want to deal with their personal information. An intermediary fact check allows you to run a zero knowledge check on that information via a trusted intermediary.
This is useful both for you and your users because you can prove a fact without ever directly interacting to them.
</p>`,url:"https://docs.joinself.com/sdk/zero/"},{value:"Document sign",label:`<p>As an app developer you may want my users to provide signatures on specific texts or documents, and have proof they agree on those documents.
Most common case is accepting your service terms and conditions.
Plain text signatures Sometimes a short text is enough, so you don&rsquo;t really need to share a PDF to be signed, in those cases you can send a document signature request like:
@app.docs.request_signature ARGV[0], terms, [] do |resp| puts &quot;Document signature : #{resp.status}&quot; end res := client.DocsService().RequestSignature(os.Args[1], terms, []documents.InputObjects) log.Println(res) let resp = await sdk.docs().requestSignature(selfID, terms, []) console.log(\`Document signature : \${resp[&quot;status&quot;]}\`) Object based signatures In case you want users to sign a document (like a PDF) you can attach objects to your request, and get a list of signed objects on the response.
objects = [] File.open('./sample.pdf') do |f| objects &lt;&lt; { name: &quot;Terms and conditions&quot;, data: f.read, mime: 'application/pdf' } end @app.docs.request_signature ARGV[0], terms, objects do |resp| if resp.status == 'accepted' puts &quot;Document signed!&quot;.green puts &quot;&quot; puts &quot;signed documents: &quot; resp.signed_objects.each do |so| puts &quot;- Name: #{so[:name]}&quot; puts &quot; Link: #{so[:link]}&quot; puts &quot; Hash: #{so[:hash]}&quot; end puts &quot;&quot; puts &quot;full signature:&quot; puts resp.input else puts &quot;Document signature #{'rejected'.red}&quot; end exit end # Check the full example on: # https://github.com/joinself/self-ruby-sdk/examples/document_sign/app.rb ds := client.DocsService() content, err := ioutil.ReadFile(&quot;./sample.pdf&quot;) if err != nil { log.Fatal(err) } objects := make([]documents.InputObject, 0) objects = append(objects, documents.InputObject{ Name: &quot;Terms and conditions&quot;, Data: content, Mime: &quot;application/pdf&quot;, }) log.Println(&quot;sending document sign request&quot;) resp, err := ds.RequestSignature(os.Args[1], &quot;Read and sign this documents&quot;, objects) if err != nil { log.Println(err.Error()) } if resp.Status == &quot;accepted&quot; { fmt.Println(&quot;Document has been signed&quot;) fmt.Println(&quot;&quot;) fmt.Println(&quot;signed documents:&quot;) spew.Dump(resp.SignedObjects) for _, o := range resp.SignedObjects { fmt.Println(&quot;- Name: &quot; + o.Name) fmt.Println(&quot; Link: &quot; + o.Link) fmt.Println(&quot; Hash: &quot; + o.Hash) } fmt.Println(&quot;&quot;) fmt.Println(&quot;full signature:&quot;) fmt.Println(resp.Signature) } let resp = await sdk.docs().requestSignature(selfID, terms, docs) if (resp[&quot;status&quot;] == &quot;accepted&quot;) { console.log(&quot;Document signed!&quot;) console.log(&quot;&quot;) console.log(&quot;signned documents: &quot;) for (var i=0; i &lt; resp[&quot;signed_objects&quot;].length; i++) { console.log(\`- Name : \${resp[&quot;signed_objects&quot;][&quot;name&quot;]}\`) console.log(\` Link : \${resp[&quot;signed_objects&quot;][&quot;link&quot;]}\`) console.log(\` Hash : \${resp[&quot;signed_objects&quot;][&quot;hash&quot;]}\`) } console.log(&quot;&quot;) console.log(&quot;full signature&quot;) console.log(resp[&quot;input&quot;]) } As you can see the signed response will come with a SHA256 hash of the original document, so you can verify the document has been signed.
</p><p>document</p><p>sign</p><p>signature</p>`,url:"https://docs.joinself.com/sdk/documentsign/"},{value:"QR",label:`<p>// TODO:
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>`,url:"https://docs.joinself.com/sdk/facts/qr/"},{value:"App direct connection",label:"<p>With this feature you&rsquo;ll be able to allow users to connect with your app offline (through a QR code or a dynamic link).\nIn addition to a regular connection, you&rsquo;ll receive a callback notification once a user is connected with your app, which means you can use that callback as an entry point to build your business logic, like sending a welcome message.\nLet&rsquo;s see an example for building this feature\nGenerating a QR code # Generates a QR code for the connection request @app.chat .generate_connection_qr .as_png(border: 0, size: 400) .save('/tmp/qr.png', :interlace =&gt; true) qrdata, _ := s.chat.GenerateConnectionQR(chat.ConnectionConfig{ Expiry: time.Minute * 5, }) // Generates a QR code for the connection request let buf = sdk.chat().generateConnectionQR() const fs = require(&lsquo;fs&rsquo;).promises; await fs.writeFile(&rsquo;/tmp/qr.png&rsquo;, buf); Generating a dynamic link link = @app.chat.generate_connection_deep_link(&quot;&quot;) link, err := s.chat.GenerateConnectionDeepLink(chat.ConnectionConfig{ Expiry: time.Minute * 5, // this is required ? }) let link = sdk.chat().generateConnectionDeepLink(&quot;&quot;) Subscribing to new connections # Register an observer for a connection response @app.chat.on_connection do |res| if res.status == &quot;accepted&quot; p &quot;successfully connected&quot; @app.chat.message(res.from, &quot;Hey there! We're connected!&quot;) end end s.chat.OnConnection(func(iss, status string) { log.Println(&quot;Response received from &quot; + iss + &quot; with status &quot; + status) parts := strings.Split(iss, &quot;:&quot;) s.chat.Message([]string{parts[0]}, &quot;Hi there!&quot;) }) sdk.chat().onConnection((res: any): any =&gt; { sdk.logger.info(`connection request ${res.status} by ${res.data.display_name}(${res.iss})`) sdk.chat().message(res.iss, &quot;hi there!&quot;) exit() }) </p><p>connection</p><p>connect</p><p>qr</p>",url:"https://docs.joinself.com/sdk/directconnection/"},{value:"Dynamic link",label:"<p></p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>",url:"https://docs.joinself.com/sdk/facts/dynamic_link/"},{value:"Voice Calls",label:`<p>The Voice library is a subset of helpers to allow your app to act as proxy between two connected users.
Voice call negotiation at self follow a workflow like this:
start starting messages instruct an identity to start a call with the issuer of the message using the same cid. accept the voice call has been accepted by the recipient, who responds with the details to start the voice call. busy notifies call issuer the recipient is busy and cannot answer the call. stop notifies the call has been ended by one of the users. SDK helpers SDKs provide helpers to subscribe and send all voice negotiation messages, so you can build things like a calling proxy. Let&rsquo;s see an example on how you could build a proxy.
@voice = client.Voice() @voice.on_start do |issuer, payload| call = Call.find_by(cid: payload[:cid]) customer = call.connection operator = call.user puts &quot;[voice_proxy] received start from #{issuer}, redirecting...&quot; @voice.start customer.selfid, payload[:cid], payload[:call_id], payload[:peer_info], { operator_name: operator.name } end @voice.on_accept do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user puts &amp;quot;[voice_proxy] received acceptation from #{issuer}, redirecting...&amp;quot; @voice.accept operator.selfid, payload[:cid], payload[:call_id], payload[:peer_info] end @voice.on_stop do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user if issuer == operator.selfid puts &amp;quot;[voice_proxy] received stop from #{issuer}, redirecting to operator&amp;quot; @voice.stop customer.selfid, payload[:cid], payload[:call_id] else puts &amp;quot;[voice_proxy] received stop from #{issuer}, redirecting to customer&amp;quot; @voice.stop operator.selfid, payload[:cid], payload[:call_id] end end @voice.on_busy do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user puts &amp;quot;[voice_proxy] received busy from #{issuer}, redirecting...&amp;quot; if issuer == operator.selfid @voice.busy customer.selfid, payload[:cid], payload[:call_id] else @voice.busy operator.selfid, payload[:cid], payload[:call_id] end end voice := client.Voice() operator := &quot;1112223334&quot; customer := &quot;1111111111&quot; voice.OnStart(func(iss, cid, callID, peerInfo string, data interface{}){ voice.Start(customer, cid, callID, peerInfo, map[string]string{ &amp;quot;operator_name&amp;quot;: &amp;quot;Bob&amp;quot;, }) }) voice.OnAccept(func(iss, cid, callID, peerInfo string, data interface{}){ voice.Accept(operator, cid, callID, peerInfo, map[string]interface{}) }) voice.OnStop(func(iss, cid, callID string) { if iss == operator { voice.Stop(customer, cid, callID) } else { voice.Stop(operator, cid, callID) } }) voice.OnBusy(func(iss, cid, callID string) { if iss == operator { voice.Busy(customer, cid, callID) } else { voice.Busy(operator, cid, callID) } }) let voice = client.Voice() let operator = &quot;1112223334&quot; let customer = &quot;1111111111&quot; voice.onStart((iss: string, cid: string, call_id: string, peer_info: string, data: any) =&gt; { voice.start(customer, cid, call_id, peer_info, { &quot;operator_name&quot;: &quot;Bob&quot;, }) }) voice.onAccept((iss: string, cid: string, call_id: string, peer_info: string, data: any) =&amp;gt; { voice.accept(operator, cid, call_id, peer_info, data) }) voice.onStop((iss: string, cid: string, call_id: string) =&amp;gt; { if (iss == operator) { voice.stop(customer, cid, call_id) } else { voice.stop(operator, cid, call_id) } }) voice.onBusy((iss: string, cid: string, call_id: string) =&amp;gt; { if (iss == operator) { voice.busy(customer, cid, call_id) } else { voice.busy(operator, cid, call_id) } }) </p><p>voice</p>`,url:"https://docs.joinself.com/sdk/voice/"},{value:"Agreements",label:"<p></p>",url:"https://docs.joinself.com/agreements/"},{value:"Joinself Docs",label:"<p></p>",url:"https://docs.joinself.com/"},{value:"QuickStart",label:"<p>Introduction Let&rsquo;s try out the Self-Quickstart app by cloning the Quickstart app on your local machine. To do this, you will need API keys which can be obtained by registering on the Self Developer Portal.\nYou have the option of obtaining credentials for two distinct environments, it is suggested to first develop and test your app on the sandbox environment, once it is stable and working as expected, you can then submit it for approval on the production environment, keep in mind that the approval process for production environment may take some time.\nEnvironments Sandbox Get started with test credentials and life-like data Production Launch your app with live credentials API Keys SELF_APP_ID Public app identifier SELF_APP_DEVICE_SECRET Private key Setting up your app Before we even get started with the code we need to have a valid Self-app credentials so the quick start can interact with the Self-network.\nThis can be done through the developer portal, if you&rsquo;re just getting started you can get those from the Sandbox Developer Portal.\nThis documentation site has a whole section describing how to create and tune your self-app for your specific needs, check it out for more detailed information. In order to prepare your app to run all the examples you should configure it properly on the portal:\nMark the app as listed Mark it as allows messaging Mark it as allows voice Additionally, you must connect to your app on your device, so you can interact with it\nQuickstart setup Once you have obtained your API keys, the next step is to execute the Self Quickstart on your local machine. The guidance provided below will assist you in duplicating the Quickstart repository, adjusting the ./examples/.env file with your own Self client ID and Sandbox secret, and ultimately, compiling and launching the application.\nThe Self-Quickstart is available in both Docker and non-Docker options. If you don&rsquo;t have Docker installed on your system, you might want to use the non-Docker version, particularly for Windows users who do not have Docker installed. However, if you already have Docker installed, it is recommended to use the Docker option as it is more straightforward and simpler to execute the Quickstart. The instructions provided below will guide you through the process of setting up the Quickstart with both Docker and non-Docker configurations.\nSetting up with Docker (Recommended) Docker is a platform and technology for building, shipping, and running distributed applications. It uses containerization, a method of packaging software in a way that ensures it runs consistently across different environments. Docker allows developers to package an application with all of its dependencies into a single container, which can then be easily deployed and run on any machine that has the Docker runtime installed. This makes it easy to manage and distribute applications, and helps ensure that the application will run consistently across different environments.\nOnce you have Docker installed, open the Docker application, and then utilize the following commands in the command line interface to set up and execute the Quickstart. In case the &lsquo;demo&rsquo; commands do not function as expected, confirm that Docker is running.\n# Notes for MacOS / Linux # Clone self-ruby-sdk $ git clone https://github.com/joinself/self-ruby-sdk.git $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env, then fill out SELF_APP_ID # and SELF_APP_DEVICE_SECRET in .env $ cp ./examples/.env.example ./examples/.env # start the container $ ./demo up # Finally run the quick start demo $ ./demo run # Notes for Windows # Clone self-ruby-sdk $ docker run -it --rm -v ${PWD}:/git alpine/git clone https://github.com/joinself/self-ruby-sdk $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env $ cp .\\examples\\.env.example .\\examples\\.env # Add SELF_APP_ID and SELF_APP_DEVICE_SECRET to .env $ notepad .\\examples\\.env # required in order to run local scripts Set-ExecutionPolicy RemoteSigned # start the container $ .\\demo.ps1 up # Finally run the quick start demo $ .\\demo.ps1 run Set-ExecutionPolicy Restricted Stop the container with ./demo down\nSetting up without Docker Self SDK comes with some dependencies on native libraries to manage encryption libself_olm and libself_omemo.\nBelow you&rsquo;ll find the instructions to get them working on your system.\nDebian/Ubuntu $ curl -O https://download.joinself.com/olm/libself-olm_0.1.17_amd64.deb $ curl -O https://download.joinself.com/omemo/libself-omemo_0.1.2_amd64.deb $ apt install libsodium-dev $ apt install ./libself-olm_0.1.17_amd64.deb ./libself-omemo_0.1.2_amd64.deb Redhat/Centos $ rpm -Uvh https://download.joinself.com/olm/libself-olm-0.1.14-1.x86_64.rpm $ rpm -Uvh https://download.joinself.com/omemo/libself-omemo-0.1.2-1.x86_64.rpm Mac (x86_64) $ brew tap joinself/crypto $ brew install libself-olm libself-omemo Mac (m1/arm64) Brew on M1 macs currently lacks environment variables needed for the sdk to find the olm and omemo libraries, so you will need to add some additional configuration to your system:\nIn your ~/.zshrc, add:\nexport C_INCLUDE_PATH=/opt/homebrew/include/ export LIBRARY_PATH=$LIBRARY_PATH:/opt/homebrew/lib You should then be able to run:\n$ source ~/.zshrc $ brew tap joinself/crypto $ brew install --build-from-source libself-olm libself-omemo Note, you may also need to create /usr/local/lib if it does not exist:\n$ sudo mkdir /usr/local/lib Setting up Quickstart # Note: If on Windows, run # git clone -c core.symlinks=true \\ # https://github.com/joinself/self-ruby-sdk.git # instead, to ensure correct symlink behavior $ git clone https://github.com/joinself/self-ruby-sdk.git $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env, then fill out SELF_APP_ID # and SELF_APP_DEVICE_SECRET in .env $ cp ./examples/.env.example ./examples/.env # start the container $ ./demo up # Finally run the quick start demo $ ./demo run Use the powershell script ./demo.ps1 instead of demo if you&rsquo;re running Windows.\nPlaying with the examples When you run the demo script for the first time, you&rsquo;ll be presented with a tty interface where you&rsquo;ll be able to test all the examples.\nNote you can modify any examples under the examples.\nThe script will be displaying you information about each of the features you&rsquo;re running and pointing you to the specific documentation on this site.\n</p>",url:"https://docs.joinself.com/quickstart/"},{value:"SDK Reference",label:`<p>Self SDKs are divided on different services, each service matches one of the products Self is offering.
Setup Setting up your client Initialize Disconnect Messaging Interacting with users through chat Send Receive Mark as read Mark as received Edit Delete Groups Interacting with users through chat Create Messaging Add users Remove users Objects Interacting with users through chat Attach a public object Attach non public objects Process incoming objects Document signature beta Interacting with users through chat Signing a plain text Signing an object Authentication Interacting with users through chat Request Request modifiers Response QR Dynamic Links Facts Interacting with users through chat Request Request modifiers Response Custom facts Recurrent Auth combination QR Dynamic Links Connections Interacting with users through chat Permit Revoke List Voice Calls Interacting with users through chat Start Accept Busy Stop Connection Interacting with users through chat Generating a QR code Generating a dynamic link Subscribing to new connections SDK Access To build an app on self-network its required to have our app installed so you can log in to the Self Developer Portal (production or sandbox).
SDK Host When you start playing with Self you likely want to use Sandbox environment environment, as it&rsquo;s easier to setup and less restrictive.
Please visit the Sandbox documentation page to download our mobile client from app stores.
Platform status and incidents Project status page is available at status.joinself.com
Client libraries Self offers official SDK libraries for different programming languages, which are regularly updated for breaking and non-breaking changes.
Ruby SDK GO SDK Typescript SDK Rust SDK Self hosted HTTP service In addition to the official SDKs we also provide a self hosted HTTP Self service that allows you to interact with the Self Network through a Rest API.
</p>`,url:"https://docs.joinself.com/sdk/"},{value:"Categories",label:"<p></p>",url:"https://docs.joinself.com/categories/"},{value:"Tags",label:"<p></p>",url:"https://docs.joinself.com/tags/"}];$("#search").autocomplete({source:e}).data("ui-autocomplete")._renderItem=function(e,t){return $("<li>").append("<a href="+t.url+' + " &quot;" +  >'+t.value+"</a>"+t.label).appendTo(e)}})</script></div></div></div></div></header><section class=section><div class=container><div class="row justify-content-center"><div class="col-lg-4 col-sm-6 mb-4"><a href=/quickstart class="px-4 py-5 bg-white shadow text-center d-block match-height"><span class=material-icons>rocket_launch</span><h3 class="mb-3 mt-0">Quickstart</h3><p class=mb-0>Learn about Self's key concepts and run a starter code</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=/sdk class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-ruler-alt-2 icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">SDK Reference</h3><p class=mb-0>Explore client-side SDK libraries and integrate with your product.</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=/agreements class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-menu-alt icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Agreements</h3><p class=mb-0>A library of Self’s terms and conditions.</p></a></div></div></div></section><section class=section><div class=container><div class="row justify-content-center"><div class="col-12 text-center"><h2 class=section-title>Explore by Product</h2></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/authentication/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-lock icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Authentication</h3><p class=mb-0>Primary & Multi-factor authentication</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/facts/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-files icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Facts</h3><p class=mb-0>Request access to user&rsquo;s sensible data</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/messaging/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-comment icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Messaging</h3><p class=mb-0>Interact with your users through messaging</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/zero/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-shield icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Zero-knowledge</h3><p class=mb-0>Check users facts without accessing sensible data</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/documentsign/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-check-box icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Document sign</h3><span class=beta>beta</span><p class=mb-0>Request document signatures</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/directconnection/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-plug icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">App direct connection</h3><p class=mb-0>Allow your customers to easily connect your app.</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/voice/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-headphone-alt icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Voice Calls</h3><p class=mb-0>Interact with voice call negotiation between users.</p></a></div></div></div></section><section><div class=container><div class=row><div class=col-12><div class="section px-3 bg-white shadow text-center"><h2 class=mb-4>Didn&rsquo;t find an answer to your question?</h2><p class=mb-4>Want to know how the Self Network can solve problems specific to your business?</p><a href=https://www.joinself.com/contact-us class="btn btn-primary">contact us</a></div></div></div></div></section><footer class="section pb-4"><div class=container><div class="row align-items-center"><div class="col-md-8 text-md-left text-center"><p class="mb-md-0 mb-4"></p></div><div class="col-md-4 text-md-right text-center"><ul class=list-inline><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://twitter.com/futureoftrust aria-label=Twitter><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://github.com/joinself/ aria-label=Github><i class=ti-github></i></a></li><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://www.linkedin.com/company/joinself/ aria-label=Linkedin><i class=ti-linkedin></i></a></li></ul></div></div></div></footer><style>.form-control{border-radius:10px!important}.banner{background-color:#0e1c42!important}.overlay::before{opacity:0!important}.bg-cover{background-size:contain;background-position:100%}</style><script src=https://docs.joinself.com/js/script.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js></script>
<script>function setCookie(e,t,n){var s=new Date;s.setTime(s.getTime()+n*24*60*60*1e3),document.cookie=e+"="+t+";path=/;expires="+s.toUTCString()}function getCookie(e){var t=document.cookie.match("(^|;) ?"+e+"=([^;]*)(;|$)");return t?t[2]:null}function defaultPageTabs(e){let n=$(".code-tabs");for(var t=0;t<n.length;t++)$(n[t]).find(".active").removeClass("active"),tab=$(n[t]).find(".tab-pane").eq(e),$(tab).addClass("active"),tabHeader=$(n[t]).find(".nav-item").eq(e),$(tabHeader).addClass("active")}$("document").ready(function(){hljs.highlightAll(),mermaid.initialize({startOnLoad:!0}),$(".nav-tabs a").click(function(){var n=$(this).parent(),t=n.index();defaultPageTabs(t),setCookie("tabIndex",t,200)}),tabIndex=getCookie("tabIndex"),tabIndex!=null&&defaultPageTabs(tabIndex)})</script><link rel=stylesheet href=/css/styles.css></body></html>