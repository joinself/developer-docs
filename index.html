<!doctype html><html lang=en-us><head><meta charset=utf-8><title>Joinself Docs</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.113.0"><meta name=description content="Joinself Docs - Joinself - Platform Documentation "><meta name=theme-name content="dot-hugo"><link rel=stylesheet href=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.css><link rel=stylesheet href=https://docs.joinself.com/plugins/themify-icons/themify-icons.css><link rel=icon href=https://docs.joinself.com/images/favicon.png type=image/x-icon><link href="https://fonts.googleapis.com/css?family=Barlow:300,400,700&display=swap" rel=stylesheet><script src=https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.js></script><style>:root{--primary-color:#0e1c42;--body-color:#f9f9f9;--text-color:#636363;--text-color-dark:#0e1c42;--white-color:#ffffff;--light-color:#f8f9fa;--font-family:Barlow}</style><link href=https://docs.joinself.com/css/style.min.css rel=stylesheet media=screen><script src=https://docs.joinself.com/plugins/jquery/jquery-1.12.4.js></script>
<script src=https://docs.joinself.com/plugins/jquery/jquery-ui.js></script>
<script src=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://docs.joinself.com/plugins/match-height/jquery.matchHeight-min.js></script><meta property="og:image" content="https://docs.joinself.com/images/logo.png"><meta property="og:image:width" content="57"><meta property="og:image:height" content="35"><meta property="og:image:type" content="image/png"><meta name=twitter:title content="Joinself Docs"><meta name=twitter:description content="Joinself - Platform Documentation"><meta property="og:title" content="Joinself Docs"><meta property="og:description" content="Joinself - Platform Documentation"><meta property="og:type" content="website"><meta property="og:url" content="https://docs.joinself.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Joinself Docs"><meta name=twitter:description content="Joinself - Platform Documentation"></head><body><header class="banner overlay bg-cover" data-background=https://docs.joinself.com/images/header.png><nav class="navbar navbar-expand-md navbar-dark"><div class="container px-2 px-md-0"><div class=navbar-brand-container><a class="navbar-brand px-2" href=/><img class=img-fluid src=https://docs.joinself.com/images/logo_white.png alt="Joinself - Platform Documentation">
<i class=navbar_docs_title>Docs</i></a></div><button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation aria-controls=navigation aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse text-center" id=navigation><ul class="navbar-nav ml-auto"><li class=nav-item><a class="nav-link text-dark" href=https://www.joinself.com>Home</a></li><li class=nav-item><a class="nav-link text-dark" href=https://www.joinself.com/contact-us>contact</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle text-dark" href=# role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>docs</a><div class=dropdown-menu><a class=dropdown-item href=https://docs.joinself.com/quickstart/>Quick Start</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/>SDK Reference</a><div class=separator>Products</div><a class=dropdown-item href=https://docs.joinself.com/sdk/authentication/>Authentication</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/messaging/>Messaging</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/facts/>Facts</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/zero/>Zero-knowledge</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/documentsign/>Document sign</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/directconnection/>Direct connection</a>
<a class=dropdown-item href=https://docs.joinself.com/sdk/voice/>Voice calls</a></div></li></ul><div class=btn-get-keys><a href=https://developer.sandbox.joinself.com target=_blank class=btn>GET API Keys</a></div></div></div></nav><div class="container section"><div class=row><div class="col-lg-8 text-center mx-auto"><h1 class="text-white mb-3">Welcome to the Docs</h1><p class="text-white mb-4">Here you&rsquo;ll find guides, resources, and references to build with Self.</p><div class=position-relative><input id=search class=form-control placeholder="Have a question? Just ask here or enter terms">
<i class="ti-search search-icon"></i>
<script>$.ui.autocomplete.filter=function(e,t){var n=new RegExp("(^| )"+$.ui.autocomplete.escapeRegex(t),"i");return $.grep(e,function(e){return n.test(e.label)||n.test(e.value)||n.test(e)})},$(function(){var e=[{value:"Client Setup",label:`<p>What is self? Self is a free to use service that lets you prove you‚Äôre a real, live person and are who you say you are, all without revealing the detail of your identity. Self keeps your data safe, secure and anonymous.
How does it work? You download the Self mobile app for free and tell it some facts about you. Then you ask friends, family, colleagues or a recognised organisation (eg: a bank) to verify that your facts are true. Your name, age, location etc‚Ä¶
The facts are stored in your secret locker (personal data store) and are never shared with anyone, but when someone needs to know your age, Self can help you provide them with a verified answer, all while keeping your data safe, secure and anonymous.
</p>`,url:"https://docs.joinself.com/sdk/setup/"},{value:"Connections",label:`<p>Permit connections Allows incoming messages from specified identities.
@client.messaging.permit_connection &quot;1234567890&quot; err := selfsdk.MessagingService().PermitConnection(&quot;1234567890&quot;) let success = await sdk.messaging().permitConnection(&quot;1234567890&quot;) Permitting incomming connections only applies if you don&rsquo;t have a global connection (*) permission. If you do, you have to revoke it first.
Permit global connections You can permit connections from everyone using an ‚Äú*‚Äù.
@client.messaging.permit_connection &quot;*&quot; err := selfsdk.MessagingService().PermitConnection(&quot;*&quot;) let success = await sdk.messaging().permitConnection(&quot;*&quot;) Revoke specific connection You can also revoke connections from a specific self identifier with:
@client.messaging.revoke_connection &quot;1234567890&quot; err := client.MessagingService().RevokeConnection(&quot;1234567890&quot;) let success = await sdk.messaging().revokeConnection(&quot;1234567890&quot;) Revoking a connection only applies if you don&rsquo;t have a global connection (*) permission setup. If you do, you have to revoke it first.
Revoke global connections Revoke connection permissions from everyone using an ‚Äú*‚Äù.
@client.messaging.revoke_connection &quot;*&quot; err := client.MessagingService().RevokeConnection(&quot;*&quot;) let success = await sdk.messaging().revokeConnection(&quot;*&quot;) Listing connections You can list your app allowed connections.
@client.messaging.allowed_connections.each do |self_id| p &quot;- '#{self_id}'&quot; end connections, _ := client.MessagingService().ListConnections() log.Println(&quot;connected to:&quot;, connections) conns = await sdk.messaging().allowedConnections() sdk.logger.info(\` - connections : \${conns.join(&quot;,&quot;)}\`) </p><p>identity</p><p>app</p><p>connect</p><p>disconnect</p><p>permit</p><p>block</p>`,url:"https://docs.joinself.com/sdk/users/connections/"},{value:"Request",label:`<p>Authentication allows you to verify a user by its ID without storing any other information about it.
On this example we will know in advance the user Self Identifier, you&rsquo;ll need to allow the user introduce its ID on your application so you can proceed with this request.
Note that by default users won&rsquo;t be connected to your app, in those cases they won&rsquo;t be receiving any incoming request, so let them know they need to be connected in advance.
Blocking request Let&rsquo;s see an easy example on how to implement an authentication workflow with the different Self SDKs.
On this example we will opt for a blocking approach, where the main execution line waits for the user response to continue.
user = &quot;1112223334&quot; authenticated = @app.authentication.request(user).accepted? user := &quot;1112223334&quot; if resp, err != client.AuthenticationService().Request(user); err != nil { println(&quot;authentication rejected&quot;) return } authenticated := resp.Accepted let res = await client.authentication().request(&quot;1112223334&quot;) let authenticated = res.isAccepted() The user will receive
Non-blocking request In contrast to blocking auth requests, there are situations where you just want to continue your execution line and set up an observer to be executed as soon as a response is received.
Let&rsquo;s say you have a conventional registration process where you let your users register to your application by its email address but you delay the email confirmation until they get back to you. This allows your users to go through a quick registration process, while you delay the data confirmation process.
# Request lets you pass a block to be executed once a response is received @client.authentication.request selfid do |auth| return auth.accepted? # The user has rejected the authentication end // Go language provides you with goroutines to // implement a non-blocking approach go func() { res, err != client.AuthenticationService().Request(selfid) if err != nil { println(&quot;authentication rejected&quot;) return } println(res.Accepted) }() async() =&gt; { try { let res = await client.authentication().request(&quot;1112223334&quot;) if(res.isAccepted() == true) { client.logger.info(\`\${res.selfID} is now authenticated ü§ò\`) } else if(res.accepted == false) { client.logger.warn(\`\${res.selfID} has rejected your authentication request\`) } else { client.logger.error(res.errorMessage) } } catch (error) { client.logger.error(error.toString()) } } Asynchronous requests This scenario is similar to non-blocking authentication, however, it‚Äôs not restricted to only one user.
Sending an asynchronous authentication request is pretty straightforward, you can do it with the async option.
This will return a conversation id identifying the authentication conversation, you should store it and catch it on a subscription, check Receiving authentication response - Subscribe section on how to manage this.
cid = @client. authentication. request(&quot;1112223334&quot;, async: true) client. AuthenticationService(). RequestAsync(&quot;1112223334&quot;, &quot;conversation_id&quot;) let res = await client. authentication(). request(&quot;1112223334&quot;, { 'async': true }) As you can see the asynchronously of this call is accomplished by an extra option or modifier Let&rsquo;s see on the next chapter what other modifiers provides the authentication workflow.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/request/"},{value:"Request",label:"<p>Blocking Same as with authentication there are situations where you want to block your execution line until the user responds to your fact request. For example, you may want to block a user&rsquo;s access to a certain space of your site until you verify its passport number.\nThis function blocks the execution line until the user responds with its verified email address.\ndef get_email(selfid) res = @client.facts.request(selfid, [:email_address]) return &quot;&quot; unless res.accepted? res.attestation_values_for(:email_address).first // Refer to Receiving fact response - Deal with request for more info rescue =&gt; e // An exception will be raised in case of a timeout or internal error return &quot;&quot; end resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, }) if err != nil { return &quot;&quot;, err } aa, err := resp.AttestationValuesFor(fact.FactEmail) if err != nil { return &quot;&quot;, err } println(aa[0]) try { let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }]) if (!res) { sdk.logger.warn(`fact request has timed out`) } else if (res.status === 'accepted') { let pn = res.attestationValuesFor('email_address')[0] sdk.logger.info(`${selfID} email address is &quot;${pn}&quot;`) } else { sdk.logger.warn(`${selfID} has rejected your authentication request`) } } catch (error) { sdk.logger.error(error.toString()) } Non-blocking The sdk also allows us to send a fact request without blocking the execution line.\nSame registration example we used for authentication works here, if you want to get a user verified fact but you don‚Äôt want the user to be blocked on the registration form, you can use this approach to continue with the execution line, and process the response as soon as it gets back.\nLet‚Äôs see how we can request a verified email address with a non-blocking request.\ndef get_email_in_background(selfid) @client.facts.request(user, [:email_address]) do |res| return &quot;&quot; unless res.accepted? return res.attestation_values_for(:email_address).first # Refer to Receiving fact response - Deal with request for more info end rescue =&gt; e # An exception will be raised in case of a timeout or internal error return &quot;&quot; end // Use goroutines to manage this scenario // Use async() = {} to manage this scenario Asynchronous The asynchronous approach can be used in scenarios like the previous one, however it has a subtle difference, you have a single observer for all information requests, which can be useful in some situations as you can have all the logic centralized on a single point.\ncid = @client.facts.request(selfid, [SelfSDK::FACT_EMAIL], async: true) resp, err := client.FactService().RequestAsync(&amp;fact.FactRequestAsync{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, CID: &quot;conversation_id&quot;, }) let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }], { async: true }) </p><p></p>",url:"https://docs.joinself.com/sdk/facts/request/"},{value:"Sandbox",label:`<p>The Self Sandbox environment is a space where software developers and users can experiment with code and applications in an isolated setting with access to all the features of Self.
This environment provides a safe place to try new things, test and debug code, and explore new ideas without affecting the live production environment.
Get your mobile client Download the Sandbox app Follow the instructions on the mobile client to signup for a new account. Once you have completed the signup process you will need to verify an email address in the mobile client under Profile &gt; Contact Details.
Login to the Sandbox Developer Portal Now you can go to the Sandbox Developer Portal and login. Once you are logged in you can create your first publisher and then your first application.
You can refer to App setup section for more information on the configuration options you have for publishers and applications.
Limitations The Self Sandbox environment is for testing, and is not suitable for production use. The Sandbox environment provides reduced perfomance and resiliency, and we periodically purge the data.
</p>`,url:"https://docs.joinself.com/quickstart/sandbox/"},{value:"Blocking requests",label:"<p>\rfacts = [{ sources: [SelfSDK::SOURCE_USER_SPECIFIED], fact: SelfSDK::FACT_EMAIL, operator: '==', expected_value: 'test@test.org' }] res = @client.facts.request_via_intermediary(selfid, facts) # GOTO Receiving fact response - Deal with the response req := fact.IntermediaryFactRequest{ SelfID: selfID, Intermediary: intermediary, Description: &quot;info&quot;, Facts: []fact.Fact{ { Fact: fact.FactDateOfBirth, Sources: []string{fact.SourceUserSpecified}, Operator: &quot;&gt;=&quot;, ExpectedValue: time.Now().Format(time.RFC3339), }, }, Expiry: time.Minute * 5, } resp, err := client.FactService().RequestViaIntermediary(&amp;req) try { let res = await sdk.facts().requestViaIntermediary(selfID, [{ fact: 'phone_number', operator: '==', sources: ['user_specified'], expected_value: '+44111222333' }]) if(!res) { sdk.logger.warn(`fact request has timed out`) } else if(res.status === &quot;unauthorized&quot;) { sdk.logger.warn(&quot;you are unauthorized to run this action&quot;) } else if (res.status === 'accepted') { sdk.logger.info(&quot;your assertion is....&quot;) sdk.logger.info(res.attestationValuesFor('phone_number')[0]) } else { sdk.logger.info(&quot;your request has been rejected&quot;) } } catch (error) { sdk.logger.error(error.toString()) } </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>blocking</p>",url:"https://docs.joinself.com/sdk/zero/blocking/"},{value:"Send and receive messages",label:`<p>Self SDK allows you to send messages to any identity on self network, this includes users, orgs and apps.
The interface used to interact with messaging is chat service, let&rsquo;s see how can we create an app automatically responding all ping messages with a pong.
@app.chat.on_message do |msg| if msg.body == &quot;ping msg.message &quot;pong&quot; end end @app.chat.message user, &quot;ready!&quot; client.ChatService().OnMessage(func(cm *chat.Message) { if cm.Body == &quot;ping&quot; { cm.Message(&quot;pong&quot;) } }) @app.chat.message user, &quot;ready!&quot; sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { if (cm.body == &quot;ping&quot;) { cm.message(&quot;pong&quot;) } }) @app.chat.message user, &quot;ready!&quot; Easy, isn&rsquo;t it? As you can see, you can use the chat service message method to send messages to a specific user, and on_message to receive them.
The object representing a message has also some handy methods to interact with that message, included sending a new message to the same conversation with message(body).
Let&rsquo;s have a closer look at all the options you have when sending and receiving messages
Sending messages The interface for sending a normal message is quite simple, just provide the user and text you want to send and that&rsquo;s it.
However, the system provides some useful options you can pass to this method. Let&rsquo;s have a look at the most important ones.
@app.chat.message user, &quot;ready!&quot;, gid: &quot;group_id&quot;, rid: &quot;uuid&quot;, client.ChatService().Message(user, &quot;ready!&quot;, chat.MessageOptions{ GID: &quot;group_id&quot;, RID: &quot;uuid&quot;, }) client.chat().message user, &quot;ready!&quot;, { &quot;gid&quot;: &quot;group_id&quot;, &quot;rid&quot;: &quot;uuid&quot; } gid You&rsquo;ll see gid option supported across different methods, gid refers to group id, and when provided will indicate the other client the current conversation is a group conversation instead of a 1 to 1 chat.
Usually this id is not used directly through this method, and instead the message is sent through a helper on Group object, check Groups for more details.
rid In this case rid is used to refer a previous message by it&rsquo;s jti, once the other party receives a rid as part of the payload it will interpret is a direct response to a specific message, and it will be displayed accordingly.
If you&rsquo;ve already received a message you want to respond, you can do it directly through the respond method like:
@app.chat.on_message do |msg| msg.respond &quot;I like this&quot; end client.ChatService().OnMessage(func(cm *chat.Message) { cm.Respond(&quot;I like this&quot;) }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.respond(&quot;I like this&quot;) }) </p><p>messaging</p><p>message</p><p>messages</p>`,url:"https://docs.joinself.com/sdk/messaging/text-messages/"},{value:"App setup",label:`<p>Now that you have logged into the Sandbox Developer Portal you are ready to create your first publisher and application.
Create a publisher To create a publisher you need to provide a name and an image for your publisher. These will be displayed to users of the Self Sandbox network.
The next step is to generate keys for your publisher. The generated keys will only be displayed once so please copy the keys and store them somewhere safe.
Create an application After you store your publisher keys somewhere safe you can create your application. Please provide a name and an image for your application. These will be displayed to users of the Self Sandbox network.
You can also decide who can connect to you application. The default setting is everyone and we recommend you leave it like that, however you can restrict access to your Self ID only if you need to.
The next step is to generate keys for your application. The generated keys will only be displayed once so please copy the keys and store them somewhere safe.
There are a number of options you can toggle on/off after you create your application:
List your app on the Self Directory: This makes it easy for users to find your application. We recommend you enable this. Allow your app to receive messages: You should enable this if you want to support chat messaging with your application. Allow your app to receive calls: You should enable this if you want to support incoming voice calls with your application. Congratulations! You are now ready to start using your new application.
</p>`,url:"https://docs.joinself.com/quickstart/app-setup/"},{value:"Connections",label:`<p>This feature allows you to manage your connections by permitting and revoking incoming messages from specific identities.
During the app creation process you can define if your app permits connections from everyone, or just you. You can tweak this behaviour as shown below.
</p>`,url:"https://docs.joinself.com/sdk/users/"},{value:"Getting started",label:`<p>Requirements To build an app on self-network its required to have our app installed so you can log in to the Self Developer Portal.
Please visit the official app stores to download our official apps for Android and iOS
Create an account Visit Self Developer Portal and follow the steps to register. You&rsquo;ll need a Self Identifier account to proceed.
App creation Self-apps are autonomous self identities able to interact with other identities on the Self-network.
A developer can create an app through the developer portal. This app will be identified by a SELF_APP_ID and a SELF_APP_DEVICE_SECRET.
SELF_APP_ID is your public identifier on the network and you can share it with other peers. You must keep SELF_APP_DEVICE_SECRET in a secure place.
You‚Äôll see below how to use these two strings to initialize your client and start interacting with the Self-network.
Remember ‚Äî copy and store SELF_APP_DEVICE_SECRET, as we don&rsquo;t have access to it.
Environments Self provides a sandbox so you can try your app code before moving to production. You can register for a free developer account and create new test apps on the Sandbox developer portal here.
Once your app is ready you can create a new one on production here
</p><p>setup</p><p>configuration</p><p>requirements</p>`,url:"https://docs.joinself.com/sdk/setup/getting-started/"},{value:"Identity types",label:`<p>Self network is formed of different entities with the ability to interact between them.
We name these entities identities and they own a self_id, an array of device ids and an array of public keys.
An identity can only communicate with another identity if IdentityA is a connection of IdentityB. If this connection is in place IdentityA will be able to request the IdentityB properties (device_ids and public keys) to interact with it.
At the moment identities can be divided into users and apps.
Getting the public keys Every single identity on the Self network has at least one public key assigned to it. Lets see how you can get the public keys related to a Self user.
@user = @client.identity.public_key &quot;1112223334&quot;, &quot;1&quot; identity, _ := client.IdentityService().GetPublicKey(&quot;1112223334&quot;, &quot;1&quot;) let key = await client.identity().publicKey(&quot;1112223334&quot;, &quot;1&quot;) Identity devices Same as with public keys each identity has at least one device.
@devices = @client.identity.devices &quot;1112223334&quot; devices _ := client.IdentityService().GetDevices(&quot;1112223334&quot;) let devices = await client.identity().devices(&quot;1112223334&quot;) </p><p>identity</p><p>app</p><p>public keys</p><p>devices</p>`,url:"https://docs.joinself.com/sdk/users/identity-types/"},{value:"Modifiers",label:`<p>Async We&rsquo;ve already covered this modifier on the Asynchronous authentication requests.
It basically allows you to send an authentication request and ignore any responses.
This is usually used in combination with an Authentication response subscription
This modifier accepts a boolean. cid = @client.authentication.request(&quot;1112223334&quot;, async: true)// Given the language nature this modifier is not implemented on Go.let res = await client.authentication().request(&quot;1112223334&quot;, { 'async': true })CID Providing a cid allows you to override the randomly generated conversation id with your own, this is useful to keep track of conversations with a preset identifier, let‚Äôs see the asynchronous example using a custom cid.
Instead of using the randomly generated conversation identifier, we can force the system to use our own unique id.
@client.authentication.request(&quot;1112223334&quot;, cid: &quot;conversation_id&quot;)client.AuthenticationService().RequestAsync(&quot;1112223334&quot;, &quot;conversation_id&quot;)let res = await client.authentication().request(&quot;1112223334&quot;, { 'cid': &quot;conversation_id&quot; })Expiration timeout Providing exp_timeout parameter permits modify the default expiration timeout of an authentication request, making it only valid for a custom time.
Its provided as an integer with the total amount of seconds you want to be valid.
@client.authentication.request(&quot;1112223334&quot;, exp_timeout: 20000)// Not supported// Not supported</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/modifiers/"},{value:"Modifiers",label:`<p>A fact request accepts some modifiers for example
CID Passing the cid or conversation id, you&rsquo;ll be able to modify the default random uuid for that request, and easily identify the related response.
exp_timeout Timeout in seconds after which the request will expire. Useful if you want your fact request to be valid just for a specific period of time. It defaults to 900 seconds.
allowed_for Providing this option with a number of seconds, your app will be allowed to request the same data without user confirmation for the specified time.
This is quite useful if you intend to use some data recurrently but don&rsquo;t want to store it on your end.
Note this option is not compatible with auth modifier for security reasons.
auth Boolean representing if you want to display this fact request as an authentication with facts or not, it will default to false.
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>modifiers</p><p>options</p>`,url:"https://docs.joinself.com/sdk/facts/modifiers/"},{value:"System dependencies",label:"<p>Self SDK depends on some native libraries to manage encryption libself_olm and libself_omemo. Below you&rsquo;ll find the instructions to get them working on your system.\nDebian/Ubuntu $ curl -O https://download.joinself.com/olm/libself-olm_0.1.17_amd64.deb $ curl -O https://download.joinself.com/omemo/libself-omemo_0.1.2_amd64.deb $ apt install libsodium-dev $ apt install ./libself-olm_0.1.17_amd64.deb ./libself-omemo_0.1.2_amd64.deb Redhat/Centos $ rpm -Uvh https://download.joinself.com/olm/libself-olm-0.1.14-1.x86_64.rpm $ rpm -Uvh https://download.joinself.com/omemo/libself-omemo-0.1.2-1.x86_64.rpm Mac (x86_64) $ brew tap joinself/crypto $ brew install libself-olm libself-omemo Mac (m1/arm64) Brew on M1 macs currently lacks environment variables needed for the sdk to find the olm and omemo libraries, so you will need to add some additional configuration to your system:\nIn your ~/.zshrc, add:\nexport C_INCLUDE_PATH=/opt/homebrew/include/ export LIBRARY_PATH=$LIBRARY_PATH:/opt/homebrew/lib You should then be able to run:\n$ source ~/.zshrc $ brew tap joinself/crypto $ brew install --build-from-source libself-olm libself-omemo Note, you may also need to create /usr/local/lib if it does not exist:\n$ sudo mkdir /usr/local/lib </p><p>setup</p><p>configuration</p><p>requirements</p>",url:"https://docs.joinself.com/sdk/setup/dependencies/"},{value:"Message actions",label:`<p>In this section we will review what actions we can take to modify the message state.
Mark as received When your app receives a message the sdk is marking it as received by default. This behavior can be changed by modifying passing a specific parameter to on_message, at the same time you can mark a message as read on your convenience, let&rsquo;s see how.
@app.chat.on_message mark_as_delivered: false do |msg| msg.mark_as_delivered # explicitly mark the message as delivered end client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsDelivered() }, chat.OnMessageOptions{ MarkAsDelivered: false }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.markAsDelivered() }, { 'mark_as_delivered': false }) Default behavior for on_message is to mark the message as received as soon as it&rsquo;s received.
Mark as read Similarly to the previous example, you can modify on_message to automatically mark all messages as read with a specific option.
@app.chat.on_message mark_as_read: true do |msg| # ... end client.ChatService().OnMessage(func(cm *chat.Message) { // ... }, chat.OnMessageOptions{ MarkAsRead: true }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { // ... }, { 'mark_as_read': true }) Additionally you can explicitly mark a received message as read with your own logic.
@app.chat.on_message do |msg| msg.mark_as_read end client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsRead() }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { cm.MarkAsRead() }) Edit For a message you&rsquo;ve already sent you can modify its body.
m = @app.chat.message user, &quot;one&quot; m.edit &quot;two&quot; m := @app.chat.message user, &quot;one&quot; m.Edit(&quot;two&quot;) let m = @app.chat.message user, &quot;one&quot; m.Edit(&quot;two&quot;) You&rsquo;re only allowed to modify your own messages.
Delete Deleting a message is as simple as modifying it, but using delete method instead.
m = @app.chat.message user, &quot;one&quot; m.delete m := @app.chat.message user, &quot;one&quot; m.Delete() let m = @app.chat.message user, &quot;one&quot; m.Delete() You&rsquo;re only allowed to delete your own messages.
</p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>`,url:"https://docs.joinself.com/sdk/messaging/actions/"},{value:"Non-blocking requests",label:`<p>@client.facts.request_via_intermediary(selfid, facts) do |res| # GOTO Receiving fact response - Deal with the response end // use language built in goroutines go func() { // ... } // use language built in async async() =&gt; { // ... } </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>non-blocking</p>`,url:"https://docs.joinself.com/sdk/zero/non-blocking/"},{value:"Authentication",label:`<p>Self provides an easy to implement Multi-factor and Biometric Authentication System, which ensures a higher level of security for your applications. The Self Authentication System allows for seamless integration of biometric authentication without the need for passwords or codes, verifying users directly from their phones.
Features Biometric authentication: Verifies users through unique biometric identifiers, such as fingerprints or facial recognition.
Privacy-focused: Authenticates users by their Self Identifier without storing any other personal information.
Easy integration: Simple implementation of authentication workflow using the Self SDKs.
Workflow A user enters their Self Identifier (ID) within your application. Your application requests authentication using the user&rsquo;s ID. The user receives an authentication request on their phone, which may require biometric verification (e.g., fingerprint or facial recognition). If the user successfully accepts the authentication request you&rsquo;ll be able to grant the current user Implementation Example The following example demonstrates how to implement an authentication workflow using the Self Ruby SDKs.
user = &quot;1112223334&quot;authenticated = @app.authentication.request(user).accepted?user := &quot;1112223334&quot;if resp, err != client.AuthenticationService().Request(user); err != nil {println(&quot;authentication rejected&quot;)return}authenticated := resp.Acceptedlet res = await client.authentication().request(&quot;1112223334&quot;)let authenticated = res.isAccepted()Steps to Implement the Authentication System Integrate the Self SDKs into your application. Allow users to enter their Self Identifier (ID) within your application. Request authentication by calling the authentication.request() method, passing the user&rsquo;s ID as an argument. Check if the authentication is accepted by evaluating the accepted? method. Benefits Enhanced security: Multi-factor and biometric authentication provides an additional layer of security for your applications, making it more difficult for unauthorized users to gain access.
Improved user experience: Users no longer need to remember complex passwords or codes, as authentication is handled through Self identifiers.
Privacy-focused: The system verifies users by their ID without storing any other personal information, reducing the risk of data breaches.
Conclusion The Multi-Factor and Biometric Authentication System offers an effective and secure way to authenticate users for your applications.
By implementing this system, you can offer your users a more convenient and secure authentication experience, while also protecting their privacy.
</p>`,url:"https://docs.joinself.com/sdk/authentication/"},{value:"Response",label:`<p>Subscribe Users can respond to authentication requests by accepting or rejecting them. On the other hand, you won‚Äôt receive asynchronous notifications for requests which have timed out.
You can subscribe to authentication responses with this snippet
@client.authentication.subscribe do |auth_res|puts resp.statusendclient.MessagingService().Subscribe(&quot;identities.authenticate.req&quot;, func(m *messaging.Message)) {// manage the response}client.messaging().subscribe(&quot;identities.authenticate.req&quot;, (res: any): any =&gt; {// manage the response})Processing the response if resp.accepted?p &quot;accepted&quot;elsif resp.rejected?p &quot;rejected&quot;elsif resp.unauthorized?p &quot;unauthorized&quot;elsif resp.errored?p &quot;errored&quot;elsep &quot;unkonwn status&quot;end// Or simply access the status string p resp.status // Go SDK will return an error for unsuccessful// responseserr = authService.Request(&quot;1112223334&quot;)if err != nil {log.Fatal(&quot;auth returned with: &quot;, err)}log.Println(&quot;authentication succeeded&quot;) try {let res = await client.authentication().request(&quot;1112223334&quot;)if(res.isAccepted() == true) {client.logger.info(\`\${res.selfID} is now authenticated ü§ò\`)} else if(res.accepted == false) {client.logger.warn(\`\${res.selfID} has rejected your authentication request\`)} else {client.logger.error(res.errorMessage)}} catch (error) {client.logger.error(error.toString())}The interesting field in an authentication response is status. Valid values for status are:
accepted The user has accepted the authentication request, so you can proceed authenticating it on your app.
rejected The user has rejected the authentication request.
unauthorized You‚Äôre unauthorized to interact with this user, let it know it needs to be connected to your app before continuing with an authentication process.
errored An internal error happened.
Depending on the SDK there are different ways you can deal with different status, see some examples below
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/response/"},{value:"Response",label:`<p>Subscribe As the user also has the option to accept or reject a fact request, the response also comes with a status property and some helpers like the authentication response.
Additionally a fact response comes with a list of attestations for the requested fact.
Subscribing to a facts response is similar to authentication.
@client.facts.subscribe do |resp|# GOTO Deal with the response for detailsend// TBDsdk.facts().subscribe((res: any): any =&gt; {// GOTO Deal with the response for details})Processing fact response The fact response will comes with a status and the same list of helpers as we described on authentication to deal with it.
Additionally each fact of the response has a list of attestations let‚Äôs see how to process them.
resp.facts.each do |fact|p fact.namefact.attestations do |a|p &quot;received #{a.value} from #{a.source}/#{a.fact} signed by #{a.origin}&quot;endendfor _, f := range resp.Facts {log.Println(f.Fact, &quot;:&quot;, f.AttestedValues())}sdk.logger.info(res.attestationValuesFor('phone_number')[0])</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>`,url:"https://docs.joinself.com/sdk/facts/response/"},{value:"Asynchronous",label:`<p>res = @client.facts.request_via_intermediary(selfid, facts, async: true) req := fact.IntermediaryFactRequest{ SelfID: os.Args[1], Intermediary: intermediary, Description: &quot;info&quot;, Facts: []fact.Fact{ { Fact: fact.FactEmail, Sources: []string{fact.SourceUserSpecified}, Operator: &quot;==&quot;, ExpectedValue: &quot;test@example.com&quot;, }, }, Expiry: time.Minute * 5, } factService := client.FactService()
resp, err := factService.RequestViaIntermediary(&amp;req) if err != nil { log.Fatal(&quot;fact request returned with: &quot;, err) }
for _, f := range resp.Facts { if f.Result() != true { log.Fatal(&quot;intermediary could not verify the required facts&quot;) } log.Printf(&quot;Your assertion that %s %s is %t\\n&quot;, f.Fact, f.Operator, f.Result()) } let res = await sdk.facts().requestViaIntermediary(selfID, facts, { 'async': true } This will return a conversation id identifying the fact request conversation, you should store it and catch it on a subscription, as described on the next section.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>async</p>`,url:"https://docs.joinself.com/sdk/zero/async/"},{value:"Group management",label:"<p>Managing group conversations is something really simple with Self SDK, let&rsquo;s see an end to end example to understand how they work.\n@groups = {} @app.chat.on_invite do |group| @groups[group.gid] = group group.join group.message(&quot;hi&quot;) end @app.chat.on_join do |msg| @groups[msg[:gid]].members &lt;&lt; msg[:iss] end @app.chat.on_leave do |msg| @groups[msg[:gid]].members.delete(msg[:iss]) end @app.chat.on_message do |msg| return if msg.gid.nil? puts &quot;[#{@groups[msg.gid].name}] #{msg.from}: #{msg.body}&quot; end groups := make(map[string]*chat.Group, 0) chat.ChatService().OnInvite(func(g *chat.Group) { g.Join() groups[g.GID] = g g.Message(&quot;hey!&quot;) }) cs.OnLeave(func(iss, gid string) { delete(groups, gid) }) chat.ChatService().OnJoin(func(iss, gid string) { if _, ok := groups[gid]; ok { groups[gid].Members = append(groups[gid].Members, iss) } }) chat.ChatService().OnMessage(func(cm *chat.Message) { if len(cm.GID) == 0 { return } fmt.Printf(&quot;[%s] %s: %s&quot;, groups[cm.GID].Name, cm.Iss, cm.Body) }) let groups = {} sdk.chat().onInvite(async (g: ChatGroup) =&gt; { g.join() groups[g.gid] = g await groups[g.gid].message(&quot;hey!&quot;) }) sdk.chat().onJoin(async (iss: string, gid: string) =&gt; { groups[gid].members.push(iss) }) sdk.chat().onLeave(async (iss: string, gid: string) =&gt; { delete groups[gid].members[iss] }) sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; { if (len(cm.gid) &gt; 0) { console.log(`[${groups[cm.gid].name}] ${cm.iss}: ${cm.body}`) } }) As you can see this example manages every group incoming message, to keep an in memory updated list of groups with its members.\nCreating a group Your app is als also able to create a group by calling invite method. members = [user1, user2, user3] @app.chat.invite &quot;my_gid&quot;, &quot;Group name&quot;, members members = []string{user1, user2, user3} client.ChatService().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members) let members = [user1, user2, user3] sdk.chat().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members) Have in mind you can send messages to a newly created group, but those messages will only be delivered to the group members that have decided to join the group.\nGroups can also have an image as avatar, you can pass a file contents as parameter to chat invite to provide that image. members = [user1, user2, user3] URI.open(&quot;https://www.avasflowers.net/img/prod_img/avasflowers-dreaming-of-tuscany-bouquet.jpg&quot;) do |image| @groups[gid] = @app.chat.invite(gid, &quot;MagicGroup&quot;, members, { data: image.read, mime: &quot;image/jpg&quot; }) end members = []string{user1, user2, user3} data, err := os.ReadFile(&quot;/tmp/dat&quot;) check(err) client.ChatService().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members, chat.InviteOptions{ Data: data, Mime: &quot;image.gif&quot;, }) import * as fs from 'fs'; let data = fs.readFileSync('foo.txt','utf8'); let members = [user1, user2, user3] sdk.chat().Invite(&quot;my_gid&quot;, &quot;Group name&quot;, members, { &quot;data&quot;: data, &quot;mime&quot;: &quot;image/gif&quot;, }) Messaging and groups Sending messages to a group is as easy as calling the message method on that group. Additionally once you receive a message on a group you will have access to all its helpers to continue the conversation without having to care about the group itself.\n</p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>",url:"https://docs.joinself.com/sdk/messaging/groups/"},{value:"Initializing your client",label:`<p>Install your client $ gem install &quot;selfsdk&quot; $ go get github.com/joinself/self-go-sdk $ npm install self-sdk We currently offer support for some basic clients. We are always happy to receive contributions to review - send us a PR, or contact us at info@joinself.com to share what you have built with us!
Language URL Go https://github.com/joinself/self-go-sdk Ruby https://github.com/joinself/self-ruby-sdk/ Typescript https://github.com/joinself/self-typescript-sdk/ Referencing the SDK SelfSDK is referenced like any other library for each specific language.
require &quot;selfsdk&quot; import &quot;github.com/joinself/self-go-sdk&quot; import SelfSDK from 'self-sdk' Storage key generation Self-SDK locally persists session and account information needed for end to end encryption. A SELF_STORAGE_KEY is required to securely encrypt this information. It is recommended that you use a large random string for your SELF_STORAGE_KEY. You can generate a random string through the command line with:
$ LC_ALL=C tr -dc '[:alnum:]' &lt; /dev/urandom | head -c64
Keep that key in a secure place as you‚Äôll need it to initialize a connection.
Basic connection A basic connection to Self network only requires your SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR.
You may want to add SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR as environment variables.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;]) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), Custom environment When you‚Äôre debugging your app, you may want to point to the sandbox environment instead of production to run your tests. You can define the environment by passing additional parameters to the Self client initialization.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;], environmnent: :sandbox) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), Environment:	&quot;sandbox&quot;, }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), { 'env': 'sandbox' }) Reconnection Self-SDK keeps a websocket connection open to self-messaging, but eventually, that connection may drop. By default Self-SDK will try to reconnect, but you can override this behaviour by passing custom parameters to initialization.
@client = SelfSDK::App.new(ENV[&quot;SELF_APP_ID&quot;], ENV[&quot;SELF_APP_DEVICE_SECRET&quot;], ENV[&quot;SELF_STORAGE_KEY&quot;], ENV[&quot;SELF_STORAGE_DIR&quot;], auto_reconnect: false) client, err := selfsdk.New(selfsdk.Config{ SelfAppID: os.Getenv(&quot;SELF_APP_ID&quot;), SelfAppDeviceSecret: os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), StorageKey: os.Getenv(&quot;SELF_STORAGE_KEY&quot;), StorageDir: os.Getenv(&quot;SELF_STORAGE_DIR&quot;), ReconnectAttempts:	-1, }) const client = await SelfSDK.build( os.Getenv(&quot;SELF_APP_ID&quot;), os.Getenv(&quot;SELF_APP_DEVICE_SECRET&quot;), os.Getenv(&quot;SELF_STORAGE_KEY&quot;), os.Getenv(&quot;SELF_STORAGE_DIR&quot;), { 'autoReconnect': false }) </p><p>install</p><p>setup</p><p>initialisation</p>`,url:"https://docs.joinself.com/sdk/setup/initialize/"},{value:"Starting the client",label:`<p>Starting your client At this point you may have your client setup, but it&rsquo;s not yet ready or connected to self network.
In order to be able to send an receive messages from the Self Network you&rsquo;ll need to call start on your client.
@client.start client.Start() client.start() A separated approach for initialize and start your client allows you to subscribe to certain events before the connection has started, and avoid missing some incoming messages.
</p><p>install</p><p>setup</p><p>start</p>`,url:"https://docs.joinself.com/sdk/setup/start/"},{value:"Glossary",label:`<p>Other Self terminology &nbsp
ACL - Access Control List An access control list (ACL) is a list of permissions attached to an object. An ACL specifies which users or system processes are granted access to objects, as well as what operations are allowed on given objects. Each entry in a typical ACL specifies a subject and an operation.
&nbsp
AISP - Account Information Service Provider Account Information Service Provider (AISP) lets you see all of your account information from different bank accounts in one place online or in a mobile app. AISPs can include budgeting apps and price comparison websites offering budgeting help and product recommendations. An AISP needs your explicit consent to provide you with these services.
&nbsp
AML - Anti Money Laundering Refers to all policies and pieces of legislation that force financial institutions to proactively monitor their clients in order to prevent money laundering and corruption.
&nbsp
API - Application Programming Interface API (application programming interface) is a set of subroutine definitions, communication protocols, and tools for building software. In general terms, it is a set of clearly defined methods of communication among various components. &nbsp
Attestation The act of an individual or organisational SelfID to attest / confirm / authenticate / validate / prove true another individual or organisational SelfIDs claim. &nbsp
Aure Self‚Äôs native token, used for paying for transactions on Self Blockchain A growing list of records, called blocks, which are linked using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data (generally represented as a merkle tree root hash). a blockchain is typically managed by a peer-to-peer network collectively adhering to a protocol for inter-node communication and validating new blocks. Once recorded, the data in any given block cannot be altered retroactively without alteration of all subsequent blocks, which requires consensus of the network majority. &nbsp
Certificate Authority A Certificate Authority (CA) is an entity that issues digital certificates. Claim A declaration by an individual or organisational SeflID of some information about itself, or an asset it owns, that is sent to one or more other individual or organisational SelfIDs to attest to. &nbsp
CLI - Command Line Interface A text-based interface that is used to operate software and operating systems while allowing the user to respond to visual prompts by typing single commands into the interface and receiving a reply in the same way. &nbsp
Cold Storage Cold storage is an offline wallet provided for storing cryptocurrencies. With cold storage, the digital wallet is stored on a platform that is not connected to the internet, thereby, protecting the wallet from unauthorised access, cyber hacks, and other vulnerabilities that a system connected to the internet is susceptible to. &nbsp
DID - Decentralised Identifier Decentralised Identifiers (DIDs) are a new type of identifier for verifiable, "self-sovereign" digital identity. DIDs are fully under the control of the DID subject, independent from any centralised registry, identity provider, or certificate authority. DIDs are URLs that relate a DID subject to means for trustable interactions with that subject. DIDs resolve to DID Documents ‚Äî simple documents that describe how to use that specific DID. Each DID Document contains at least three things: cryptographic material, authentication suites, and service endpoints. Cryptographic material combined with authentication suites provide a set of mechanisms to authenticate as the DID subject (e.g., public keys, pseudonymous biometric protocols, etc.). Service endpoints enable trusted interactions with the DID subject. &nbsp
Digital Certificate The digital certificate also known as public key certificate, or identity certificate certifies the ownership of a public key by the named subject of the certificate. This allows others (relying parties) to rely upon signatures or assertions made by the private key that corresponds to the public key that is certified. &nbsp
DLT - Distributed Ledger Technology A distributed ledger is a database that is consensually shared and synchronised across network spread across multiple sites, institutions or geographies. It allows transactions to have public "witnesses," thereby making a cyberattack more difficult. The participant at each node of the network can access the recordings shared across that network and can own an identical copy of it. Further, any changes or additions made to the ledger are reflected and copied to all participants in a matter of seconds or minutes. &nbsp
DRI - Directly Responsible Individual Directly Responsible Individual relates to the person who is allocated as the owner of an Epic or a specific task. &nbsp
DUNS Number The DUNS number is a nine-digit number, issued and regulated by D&B (Dun & Bradstreet - a company that provides commercial data, analytics, and insights for businesses). It is assigned to a single business entity, having a unique, separate, and distinct operation for the purpose of identifying them. &nbsp
E2E - End-to-end End to End encryptions allows only the users communicating can read the messages. &nbsp
Epic Epics represent the specific tasks or a body of work that can be broken down into use cases. Milestones consist of a number of Epics to be completed. &nbsp
FCA - Financial Conduct Authority The Financial Conduct Authority is a financial regulatory body in the United Kingdom, but operates independently of the UK Government. &nbsp
Hash Encoding of data in to a small and generally fixed size &nbsp
HLF - Hyperledger Fabric A Fabric permissioned blockchain network is a technical infrastructure that provides ledger services to application consumers and administrators. In most cases, multiple organisations come together as a consortium to form the network and their permissions are determined by a set of policies that are agreed to by the consortium when the network is originally configured. Moreover, network policies &nbsp
Horizon API Server Horizon is an API server for the Stellar ecosystem. It acts as the interface between stellar-core and applications that want to access the Stellar network. It allows you to submit transactions to the network, check the status of accounts, subscribe to event streams, etc. &nbsp
Hot Storage Hot storage is online wallet provided for storing cryptocurrencies. With hot storage, the digital wallet is stored on a platform that is connected to the internet. Differently from a cold storage, a hot storage is subjected to unauthorised access, cyber hacks, and other vulnerabilities that a system connected to the internet is susceptible to. &nbsp
Hyperledger Hyperledger is a multi-project open source collaborative effort hosted by The Linux Foundation. We are using it to store the self ID into a public key mapping, and potentially to store the SelfID score too. &nbsp
JWE - JSON Web Encryption JSON Web Encryption is an IETF standard providing a standardised syntax for the exchange of encrypted data, based on JSON and Base64. It forms part of the JavaScript Object Signing and Encryption (JOSE) suite of protocols. &nbsp
JWS - JSON Web Signature JSON Web Signature is an IETF proposed standard [RFC7515] for signing arbitrary data. JWS is a way to ensure integrity of information in a highly serialisable, machine-readable format. That means that it is information, along with proof that the information hasn't changed since being signed. It can be used for sending information from one web site to another, and is especially aimed at communications on the web. It even contains a compact form optimised for applications like URI query parameters. &nbsp
JWT - JSON Web Tokens JWT - JSON Web Tokens is a JSON-based open standard (RFC 7519) for creating access tokens that assert a certain number of claims. For example, a server could generate a token that has the claim "logged in as admin" and provide that to a client. The client could then use that token to prove that it is logged in as admin. &nbsp
K8S The container orchestration tool that hosts the Self platform. &nbsp
KYC - Know Your Customer Know your Customer (Client) checks allows businesses to verify the identity of their clients. Guidelines are often dictated by government or financial authorities such as the FCA. &nbsp
Node A node is a device on a blockchain network, that is in essence the foundation of the technology, allowing it to function and survive. The role of a node is to support the network by maintaining a copy of a blockchain and, in some cases, to process transactions. &nbsp
OAuth - Open Authorisation OAuth is a simple way to interact with private data, allowing third parties limited access to a web-service via access tokens at the authorisation of the account owner. &nbsp
Open Banking The use of open API‚Äôs to enable third parties access to details from an individual's bank account. &nbsp
Oracle An oracle, in the context of blockchains and smart contracts, is an agent that finds and verifies real-world occurrences and submits this information to a blockchain to be used by smart contracts. ... An oracle is a data feed ‚Äì provided by third party service ‚Äì designed for use in smart contracts on the blockchain. In the case of Self/Biler a good example is the Client Payment Oracle/Fiat Currency Gateway. This gets notified by webhook from the bank (ideally) of the deposit of fiat currency into a client money account, it then credits the deposited fiat funds with a corresponding tokenized form of the currency which can be controlled by a User‚Äôs private keys. &nbsp
P2P - Peer-to-peer Peer-to-peer computing is a distributed application architecture that partitions workloads between peers. &nbsp
PDS - Personal Data Store A platform where people can securely store, manage and share their data. &nbsp
PIFI - Personally Identifiable Financial Information Personally identifiable financial information (PIFI) is any type of personally identifiable information (PII) that is linked to that person's finances. A credit card number is a prime example of PIFI. &nbsp
PII - Personally Identifiable Information Personally identifiable information (PII) is any data that could potentially identify a specific individual. Any information that can be used to distinguish one person from another and can be used for de-anonymising anonymous data can be considered PII. PII can be sensitive or non-sensitive. Non-sensitive PII is information that can be transmitted in an unencrypted form without resulting in harm to the individual. Non-sensitive PII can be easily gathered from public records, phone books, corporate directories and websites.
Sensitive PII is information which, when disclosed, could result in harm to the individual whose privacy has been breached. Sensitive PII should, therefore, be encrypted in transit and when data is at rest. Such information includes biometric information, medical information, personally identifiable financial information (PIFI) and unique identifiers such as passport or Social Security numbers.
&nbsp
PISP - Payment Initiation Service Provider A Payment Initiation Service Provider (PISP) lets you pay companies directly from your bank account rather than using your debit or credit card through a third-party such as Visa or MasterCard. A PISP needs your explicit consent before providing you with this kind of service. &nbsp
PKI - Public Key Infrastructure A public key infrastructure (PKI) is a set of roles, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption. &nbsp
Ripple Ripple is a real-time gross settlement system, currency exchange and remittance network created by Ripple Labs Inc. that provides one frictionless experience to send money globally using the power of blockchain and the XRP token. &nbsp
SC - Smart Contract Smart contracts are self-executing contracts with the terms of the agreement between buyer and seller being directly written into lines of code. The code and the agreements contained therein exist across a distributed, decentralised blockchain network. A smart contract is a computer protocol intended to digitally facilitate, verify, or enforce the negotiation or performance of a contract. Smart contracts allow the performance of credible transactions without third parties. These transactions are trackable and irreversible. Stablecoin/Stable Token
A stablecoin is a cryptocurrency designed to minimise the price volatility. Stablecoins are used as stores of value or units of account, as well as in other use cases where volatile cryptocurrencies may be less desirable. Authors of stablecoins use different designs to achieve price stability. The value of a stablecoin can be pegged to fiat currencies, or to exchange traded commodities (such as gold, silver, other precious and industrial metals, etc). Stablecoins can be centralised where they can be backed by fiat and exchange-traded commodities directly, or in a decentralised fashion via leveraging other cryptocurrency projects in different ways.
&nbsp
Stellar Stellar is an open-source, decentralised protocol for digital currency to fiat currency transfers which allows cross-border transactions between any pair of currencies using the XLM token. &nbsp
Token Crypto tokens are special kind of virtual currency tokens that reside on their own blockchains and represent an asset or utility. For example, one can have a crypto token that represents x number of customer loyalty points on a blockchain that is used to manage such details for a retail chain. &nbsp
TrustLine (Stellar/Ripple Specific) The Trustlines Network is the original Ripple idea built on Ethereum. The Trustlines Network targets the problem of fair access to money by implementing money as bilateral peer-to-peer issued blockchain-based credit. We are developing an open source protocol, including a mobile app empowering end-users to make global payments based on their existing trusted social network. &nbsp
UID - Unique Identifier A unique identifier (UID) is a numeric or alphanumeric string that is associated with a single entity within a given system. UIDs make it possible to address that entity so that it can be accessed and interacted with. &nbsp
Use Case Use Cases are a list of actions or event steps between a role and a system to achieve a goal, and typically consist of a set of possible scenarios between the two. &nbsp
Verifier The party who needs to trust a claim &nbsp
VoIP - Voice over IP Voice over Internet Protocol delivers voice communications over the internet, likely meaning it is lower cost. An example of this would be Skype. &nbsp
WOT - Web of Trust a web of trust is a concept used in PGP, GnuPG, and other OpenPGP-compatible systems to establish the authenticity of the binding between a public key and its owner. Its decentralised trust model is an alternative to the centralised trust model of a public key infrastructure (PKI), which relies exclusively on a certificate authority (or a hierarchy of such). As with computer networks, there are many independent webs of trust, and any user (through their identity certificate) can be a part of, and a link between, multiple webs. &nbsp
ZKP - Zero Knowledge Proofs A zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that something is true, without revealing any information apart from the fact that this specific statement is true. </p>`,url:"https://docs.joinself.com/quickstart/glossary/"},{value:"Facts",label:`<p>A Facts is a statement about an identity. Verified facts are facts that have been attested to by trusted issuer(s).
A single fact can be verified by multiple issuers and so have multiple assertions. Verified facts are held by identities and can be shared with other identities (relying parties) who require them.
Facts and related attestations are stored on the user‚Äôs device, so the user has full control over who can access its information.
Each fact has the following properties:
Sources A fact‚Äôs source represents where this fact comes from, for example a DOB can come from different sources such as a passport or a driving license. By default this field is set with a wildcard ‚Äú*‚Äù and the user will select the source on their device. Same happens if you specify multiple sources.
At the moment there are three different sources user_specified, passport and driving_license.
As this list is always growing, you can check the possible values on your SDK ruby-sdk and go-sdk.
Fact This is the name of the fact you want to request like display_name, email_address or phone_number.
The list of values by source is:
user_specified: display_name, email_address and phone_number passport and _identity-card _: document_number, surname, given_names, date_of_birth, date_of_expiration, sex, nationality, _country_of_issuance. driving_license : document_number, surname, given_names, date_of_birth, date_of_issuance, date_of_expiration, address, issuing_authority, place_of_birth, country_of_issuance. Attestations A list of verified attestations signed by an issuer. This only has content on fact request responses, and it contains a list of attestations for the current fact.
Expected value When you send an intermediary fact check you expect the value of a user‚Äôs fact to be compared with an expected value, this field is where you will provide that value.
Operator On an intermediary fact check this field contains the operator used to compare the expected value against the expected value. Valid operators can be found here
Fact requests Fact requests allow your app to request specific facts from identities on the Self-network.
Only verified facts can be requested
The approaches to request facts are similar to authentication, so let&rsquo;s have a look at them.
By default fact requests will expire after 15 minutes, you can change this defaults with \`Expiry\` option.</p>`,url:"https://docs.joinself.com/sdk/facts/"},{value:"QR",label:`<p>Presenting users with a QR makes your authentication workflow more convenient for users on non-mobile devices.
The authentication workflow using QR codes allows users to authenticate on your project without handwriting its self identifier, just by scanning the QR code you&rsquo;re providing.
# Generate a QR code to authenticate @app.authentication .generate_qr .as_png(border: 0, size: 400) .save('/tmp/qr.png', :interlace =&gt; true) qrdata, err := s.auth.GenerateQRCode(&amp;authentication.QRAuthenticationRequest{ QRConfig: fact.QRConfig{ Size: 400, BackgroundColor: &quot;#FFFFFF&quot;, ForegroundColor: &quot;#000000&quot;, }, }) let buf = sdk.authentication().generateQR() const fs = require('fs').promises; await fs.writeFile('/tmp/qr.png', buf); Once the user scans the QR code with its device and accepts the authentication request, it will send back an authentication response to your app.
Have in mind the user&rsquo;s device will send you back an authentication response, so setup a subscription to that topic.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/qr/"},{value:"Attachments / objects",label:`<p>Sharing an image, a document or just a gif is an important part of your users daily messaging, the SDK allows your app to send this kind of messages as well. Let&rsquo;s see how.
Public objects Most of the time we only share public images, and in this case we don&rsquo;t require the document to be encrypted, so we can directly share the URL.
opts = { objects: [{ link: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, name: &quot;homer&quot;, mime: &quot;image/gif&quot;, }] } client.message user, &quot;ready!&quot;, opts obj := chat.MessageObject{ Name: &quot;Hello&quot;, Link: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, Mime: &quot;image/gif&quot;, } m, err = client.ChatService().Message([]string{os.Args[1]}, &quot;no way...&quot;, chat.MessageOptions{ Objects: []chat.MessageObject{obj}, }) opts = { &quot;objects&quot;: [{ &quot;link&quot;: &quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif&quot;, &quot;name&quot;: &quot;homer&quot;, &quot;mime&quot;: &quot;image/gif&quot;, }]} client.chat().message user, &quot;ready!&quot;, opts) Non-public objects All non-public objects shared between identities are encrypted by default using Poly1305. This encryption layer is built on the SDK, so should be transparent for end users. Let&rsquo;s see how we can send a local file.
URI.open(path) do |image| name = &quot;image.#{path.split(&quot;.&quot;).last}&quot; mime = &quot;image/#{path.split(&quot;.&quot;).last}&quot; msg.message(&quot;your image sir...&quot;, objects: [{ name: name, data: image.read, mime: mime }]) end data, err := os.ReadFile(&quot;/tmp/dat&quot;) check(err) m, err = cs.Message([]string{os.Args[1]}, &quot;your file sir...&quot;, chat.MessageOptions{ Objects: []chat.MessageObject{chat.MessageObject{ Name: &quot;image.gif&quot;, Data: data, Mime: &quot;image/gif&quot;, }}, }) import * as fs from 'fs'; let data = fs.readFileSync('foo.txt','utf8'); client.chat().message user, &quot;your file sir...&quot;, { &quot;objects&quot;: [{ &quot;data&quot;: data, &quot;name&quot;: &quot;image.gif&quot;, &quot;mime&quot;: &quot;image/gif&quot;, }]}) </p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>object</p><p>image</p><p>file</p>`,url:"https://docs.joinself.com/sdk/messaging/objects/"},{value:"Subscribe to zero knowledge fact check",label:`<p>A subscription to an intermediary fact check response behaves exactly the same as a basic fact response.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>subscribe</p>`,url:"https://docs.joinself.com/sdk/zero/subscribe/"},{value:"Disconnecting",label:`<p>You should gracefully manage the client disconnection by calling close method. If a connection is not gracefully closed Self messaging servers will kill that connection after one minute.
@client.close client.Close() client.close() </p><p>setup</p><p>disconnecting</p><p>shut down</p><p>stop</p><p>close</p>`,url:"https://docs.joinself.com/sdk/setup/disconnect/"},{value:"Custom",label:`<p>Self Core Facts are useful for general purpose, but the process of adding new core facts is slow and not flexible enough to support app custom facts.
Custom facts will allow you to:
Create custom facts. Store facts on the user&rsquo;s device. Consume custom facts. Share custom facts with other apps. Interact with other apps on the Self ecosystem. All this is basically accomplished by using the user&rsquo;s device as secure storage for critical information.
Issuing facts Groups Facts are presented to the user in groups. Groups have name and icon properties.
param description required name The name of the group as it will be displayed to the user. true icon The icon to be displayed close to the group name false Self App supports all material UI icons, you can search all available icons on google fonts.
This is how we can create a group.
my_group = SelfSDK::Services::Facts::Group.new( &quot;Trip to Venice&quot;, &quot;airplanemode_active&quot; ) g := fact.FactGroup{ Name: &quot;Trip to Shangai&quot;, Icon: &quot;airplanemode_active&quot;, } let group = new Group(&quot;group name&quot;, &quot;plane&quot;) Facts Facts are composed of a key, a value and a source.
param description required key is the id for the fact, it will allow other apps to request your facts by id. true value It&rsquo;s stored as a string by default true source it groups facts from the same source, it allows other apps to use it as filters. true group if group is not provided facts will end under on the ungrouped section on the user&rsquo;s device false type it defines how the fact has to be processed by other clients, it defaults to string, but can also be set as password or delegation_certificate false my_fact = SelfSDK::Services::Facts::Fact.new( &quot;confirmation_code&quot;, &quot;CD128763&quot;, &quot;source12&quot;, group: my_group) f := fact.FactToIssue{ Key: &quot;BCN-SIN-cc&quot;, Value: &quot;CD128763&quot;, Source: source, Group: &amp;g, } let fact = new FactToIssue(&quot;foo&quot;, &quot;bar&quot;, source, { group: group }) Issuing facts Once you have your fact defined, it&rsquo;s time to send it to your user&rsquo;s device. You can do this by calling issue method on the facts service.
param description required user the user you&rsquo;re signing and sending facts to true facts an array with the facts you want to issue true viewers an array of app identifiers related to apps apps that can consume this facts false @app.facts.issue(user, my_fact], viewers: [appID1, appID2]) client.FactService().Issue(selfid, []fact.FactToIssue{f}, []string{}) await sdk.facts().issue(selfID, [fact]) Retrieving facts Retrieving facts is pretty much the same as we do for accessing core facts, the only difference is we must specify what issuers are we going to be accepting on our request, let&rsquo;s see an example.
myAppID = ENV[&quot;SELF_APP_ID&quot;] @app.facts.request(user, [{ fact: my_fact.key, issuers: [myAppID] }]) do |res| if res.status == &quot;rejected&quot; puts 'Information request rejected' exit! end k = my_fact.key.to_sym a = res.attestation_values_for(k) puts &quot;Your stored fact is #{a.first}!&quot; end resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfid, Description: &quot;We need access to your flight confirmation codes to reschedule your flights&quot;, Facts: []fact.Fact{ { Fact: f[0].Key, Sources: []string{source}, Issuers: []string{appID}, }, }, Expiry: time.Minute * 5, }) let res = await sdk.facts().request(selfID, [{ fact: fact.key, issuers: [ appID ] }]) Scope and facts Custom facts scope is configurable by the developer by using viewers and issuers parameters to facts.issue and facts.request. This makes it possible to create private, protected and public custom facts.
Private By specifying yourself as the only viewers on a facts.issue you will be creating facts you&rsquo;re the only one able to consume.
Protected Specifying multiple app ids as viewers you&rsquo;ll make those facts available only to a subset of apps.
Public When viewers parameter is not provided, issued facts become public.
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>custom</p>`,url:"https://docs.joinself.com/sdk/facts/custom/"},{value:"Dynamic link",label:`<p>When you&rsquo;re authenticating users on your platform straight on their mobile devices, is when dynamic links are more useful.
A dynamic link will authenticate a user on your platform by clicking a link and accepting the authentication request on his phone.
As part of this process, you have to share the generated link with your users, and wait for a response.
In order to use a dynamic link, you must generate a redirection code on the developer portal, once you have it you can use it to generate a url which you can share with your users.
url = @client.authentication.generate_deep_link(redirection_code) link, err := authService.GenerateDeepLink(&amp;authentication.DeepLinkAuthenticationRequest{ ConversationID: cid, Callback: redirectionCode, Expiry: time.Minute * 5, }) if err != nil { log.Fatal(&quot;auth returned with: &quot;, err) } let url = sdk.authentication().generateDeepLink(redirectionCode) Have in mind the user&rsquo;s device will send you back an authentication response, so setup a subscription to that topic.
</p><p></p>`,url:"https://docs.joinself.com/sdk/authentication/dynamic_link/"},{value:"Messaging",label:`<p>The Self SDK provides a comprehensive set of messaging capabilities, allowing developers to integrate secure and privacy-focused communication features into their applications.
With Self, you can enable end-to-end encrypted messaging between users, support group messaging, exchange encrypted attachments, and implement various message actions.
This documentation describes the features, functionalities, and implementation details of the Self SDK.
Implementation Example Simple ping-pong messaging example
@app.chat.on_message do |msg|if msg.body == &quot;pingmsg.message &quot;pong&quot;endend@app.chat.message user, &quot;ready!&quot;client.ChatService().OnMessage(func(cm *chat.Message) {if cm.Body == &quot;ping&quot; {cm.Message(&quot;pong&quot;)}})@app.chat.message user, &quot;ready!&quot;sdk.chat().OnMessage(async (cm: ChatMessage) =&gt; {if (cm.body == &quot;ping&quot;) {cm.message(&quot;pong&quot;)}})@app.chat.message user, &quot;ready!&quot;Privacy-Focused The Self SDK prioritizes privacy by employing end-to-end encryption for all communications.
This ensures that only the sender and the intended recipient of the messages have access to the shared data.
The SDK implements industry-standard encryption algorithms and protocols, ensuring that sensitive user information remains secure and protected.
Easy Integration Implementing the Self SDK into your application is straightforward, enabling you to quickly enhance your communication capabilities.
The SDK provides a simple and intuitive API, allowing developers to seamlessly integrate messaging features into their existing codebase.
With comprehensive documentation and code examples, the integration process becomes smooth and hassle-free.
Text messages API
Group Messaging The Self SDK includes built-in support for group messaging, enabling users to participate in secure conversations with multiple participants.
Developers can easily create and manage groups, invite users, and facilitate encrypted messaging among group members.
The SDK&rsquo;s group messaging functionality ensures that communication within groups is private and protected.
Group management docs
Attachments With the Self SDK, you can enrich your messaging experience by exchanging encrypted chat objects such as documents, images, and other attachments.
The SDK provides a convenient interface for attaching files to messages, ensuring the secure transmission of sensitive information.
Whether it&rsquo;s sharing important documents or captivating images, the Self SDK allows users to exchange attachments with peace of mind.
Attachments docs
Message Actions The Self SDK offers a range of message actions that developers can implement to enhance the messaging experience.
These actions include marking messages as received or read, modifying message content, and deleting messages.
By implementing message actions, users can have more control over their conversations, ensuring that messages accurately reflect their communication status and preferences.
Conclusion The Self SDK empowers developers to integrate robust and privacy-focused messaging capabilities into their applications.
With end-to-end encryption, easy integration, group messaging support, attachment exchange, and flexible message actions, the SDK provides a comprehensive solution for secure communication.
By leveraging the Self SDK, developers can enhance their applications with privacy-focused messaging features, creating a secure and reliable communication platform for their users.
</p>`,url:"https://docs.joinself.com/sdk/messaging/"},{value:"Zero knowledge fact responses",label:`<p>This is similar to the fact request, the only difference in this case is that the attestation.value will always be a boolean indicating if your check is accomplished or not.
</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>response</p>`,url:"https://docs.joinself.com/sdk/zero/response/"},{value:"Notify",label:`<p>It prompts the user with a push notification or badge with a specific message. The message will be available on the notifications screen.
@client.messaging.notify &quot;1234567890&quot;, &quot;Hello world!&quot; err := client.MessagingService().Notify(&quot;1234567890&quot;, &quot;Hello world!&quot;) await sdk.messaging().notify(&quot;1234567890&quot;, &quot;Hello world!&quot;) </p><p>notify</p><p>notifications</p><p>push notification</p>`,url:"https://docs.joinself.com/sdk/notify/"},{value:"Recurrent requests",label:`<p>As we&rsquo;ve seen on Facts section you can request user&rsquo;s verified sensible data through facts service.
This becomes really useful when you can use the data at the moment. However, if you need to access the same data periodically or some time in the future, you&rsquo;ll be forced to store it.
Self recurrent requests feature allows you to access the same data for a specific period of time without having to wait for user&rsquo;s acceptance, so you don&rsquo;t need to store it on your servers.
Recurrent requests looks exactly the same as a regular fact request, except it makes use of allowed_for modifier, let&rsquo;s see an example.
ten_days = 10 * 60 * 60 * 60 # Request email, with recurrent requests enabled for ten days res = @client.facts.request(user, [:email_address], allowed_for: ten_days) # At this point the user will be prompted with a confirmation box to # allow access its email for the next 10 days. # # If we send the same request again, it will be automatically shared by the device # without user interaction. res = @client.facts.request(user, [:email_address]) // Request email, with recurrent requests enabled for ten days resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, AllowedFor: time.Day * 10, }) check(err) // At this point the user will be prompted with a confirmation box to // allow access its email for the next 10 days. // // If we send the same request again, it will be automatically shared by the device // without user interaction. resp, err := client.FactService().Request(&amp;fact.FactRequest{ SelfID: selfID, Description: &quot;info&quot;, Facts: []fact.Fact{{ Fact: fact.FactEmail }}, Expiry: time.Minute * 5, }) check(err) let tenDays = 10 * 60 * 60 * 60 // Request email, with recurrent requests enabled for ten days let res = await sdk.facts().request(user, [{ fact: &rsquo;email_address&rsquo;, allowed_for: tenDays }]) // At this point the user will be prompted with a confirmation box to // allow access its email for the next 10 days. // // If we send the same request again, it will be automatically shared by the device // without user interaction. let res = await sdk.facts().request(user, [{ fact: &rsquo;email_address&rsquo; }]) Given the user is always able to cancel this recurrent requests at any time, it&rsquo;s highly recommended to include the allowed for modifier on every request.
Even the responses to your fact requests are automated by the user, have in mind the request always hits the user&rsquo;s device, so the response can take some time to get back to you..
</p>`,url:"https://docs.joinself.com/sdk/facts/recurrent/"},{value:"Combined",label:`<p>Many times, specially on a registration process you want your users to authenticate and at the same time you require some sort of specific facts, for example name or email.
Facts service allows you to send a fact request with the form of an authentication, with the option auth
cid = @client.facts.request(selfid, [SelfSDK::FACT_EMAIL], async: true, auth: true)req := fact.FactRequestAsync{SelfID: selfID,Description: &quot;info&quot;,Facts: []fact.Fact{{ Fact: fact.FactEmail }},Expiry: time.Minute * 5,CID: &quot;conversation_id&quot;,Auth: true,}resp, err := client.FactService().RequestAsync(&amp;req) if err != nil { return &quot;&quot;, err } let res = await sdk.facts().request(selfID, [{ fact: 'email_address' }], { async: true, auth: true })</p><p>auth</p><p>facts</p><p>request</p><p>registration</p>`,url:"https://docs.joinself.com/sdk/facts/combined/"},{value:"Zero-knowledge",label:`<p>An easy to use zero knowledge fact checker allows developers to ask the questions they really need an answer to, and receive anonymised answers.
That means they need to worry less about running a secure compliant environment.
How do they work? Intermediary fact checks are useful when you want to run a check of a user‚Äôs verified fact without having to gain access to that fact.
Eg. You want to verify a user is over 18, but you don‚Äôt want to deal with their personal information. An intermediary fact check allows you to run a zero knowledge check on that information via a trusted intermediary.
This is useful both for you and your users because you can prove a fact without ever directly interacting to them.
</p>`,url:"https://docs.joinself.com/sdk/zero/"},{value:"Document sign",label:"<p>As an app developer you may want my users to provide signatures on specific texts or documents, and have proof they agree on those documents.\nMost common case is accepting your service terms and conditions.\nPlain text signatures Sometimes a short text is enough, so you don&rsquo;t really need to share a PDF to be signed, in those cases you can send a document signature request like:\n@app.docs.request_signature ARGV[0], terms, [] do |resp| puts &quot;Document signature : #{resp.status}&quot; end res := client.DocsService().RequestSignature(os.Args[1], terms, []documents.InputObjects) log.Println(res) let resp = await sdk.docs().requestSignature(selfID, terms, []) console.log(`Document signature : ${resp[&quot;status&quot;]}`) Object based signatures In case you want users to sign a document (like a PDF) you can attach objects to your request, and get a list of signed objects on the response.\nobjects = [] File.open('./sample.pdf') do |f| objects &lt;&lt; { name: &quot;Terms and conditions&quot;, data: f.read, mime: 'application/pdf' } end @app.docs.request_signature ARGV[0], terms, objects do |resp| if resp.status == 'accepted' puts &quot;Document signed!&quot;.green puts &quot;&quot; puts &quot;signed documents: &quot; resp.signed_objects.each do |so| puts &quot;- Name: #{so[:name]}&quot; puts &quot; Link: #{so[:link]}&quot; puts &quot; Hash: #{so[:hash]}&quot; end puts &quot;&quot; puts &quot;full signature:&quot; puts resp.input else puts &quot;Document signature #{'rejected'.red}&quot; end exit end # Check the full example on: # https://github.com/joinself/self-ruby-sdk/examples/document_sign/app.rb ds := client.DocsService() content, err := ioutil.ReadFile(&quot;./sample.pdf&quot;) if err != nil { log.Fatal(err) } objects := make([]documents.InputObject, 0) objects = append(objects, documents.InputObject{ Name: &quot;Terms and conditions&quot;, Data: content, Mime: &quot;application/pdf&quot;, }) log.Println(&quot;sending document sign request&quot;) resp, err := ds.RequestSignature(os.Args[1], &quot;Read and sign this documents&quot;, objects) if err != nil { log.Println(err.Error()) } if resp.Status == &quot;accepted&quot; { fmt.Println(&quot;Document has been signed&quot;) fmt.Println(&quot;&quot;) fmt.Println(&quot;signed documents:&quot;) spew.Dump(resp.SignedObjects) for _, o := range resp.SignedObjects { fmt.Println(&quot;- Name: &quot; + o.Name) fmt.Println(&quot; Link: &quot; + o.Link) fmt.Println(&quot; Hash: &quot; + o.Hash) } fmt.Println(&quot;&quot;) fmt.Println(&quot;full signature:&quot;) fmt.Println(resp.Signature) } let resp = await sdk.docs().requestSignature(selfID, terms, docs) if (resp[&quot;status&quot;] == &quot;accepted&quot;) { console.log(&quot;Document signed!&quot;) console.log(&quot;&quot;) console.log(&quot;signned documents: &quot;) for (var i=0; i &lt; resp[&quot;signed_objects&quot;].length; i++) { console.log(`- Name : ${resp[&quot;signed_objects&quot;][&quot;name&quot;]}`) console.log(` Link : ${resp[&quot;signed_objects&quot;][&quot;link&quot;]}`) console.log(` Hash : ${resp[&quot;signed_objects&quot;][&quot;hash&quot;]}`) } console.log(&quot;&quot;) console.log(&quot;full signature&quot;) console.log(resp[&quot;input&quot;]) } As you can see the signed response will come with a SHA256 hash of the original document, so you can verify the document has been signed.\n</p><p>document</p><p>sign</p><p>signature</p>",url:"https://docs.joinself.com/sdk/documentsign/"},{value:"QR",label:`<p>// TODO:
</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>`,url:"https://docs.joinself.com/sdk/facts/qr/"},{value:"App direct connection",label:"<p>With this feature you&rsquo;ll be able to allow users to connect with your app offline (through a QR code or a dynamic link).\nIn addition to a regular connection, you&rsquo;ll receive a callback notification once a user is connected with your app, which means you can use that callback as an entry point to build your business logic, like sending a welcome message.\nLet&rsquo;s see an example for building this feature\nGenerating a QR code # Generates a QR code for the connection request @app.chat .generate_connection_qr .as_png(border: 0, size: 400) .save('/tmp/qr.png', :interlace =&gt; true) qrdata, _ := s.chat.GenerateConnectionQR(chat.ConnectionConfig{ Expiry: time.Minute * 5, }) // Generates a QR code for the connection request let buf = sdk.chat().generateConnectionQR() const fs = require(&lsquo;fs&rsquo;).promises; await fs.writeFile(&rsquo;/tmp/qr.png&rsquo;, buf); Generating a dynamic link link = @app.chat.generate_connection_deep_link(&quot;&quot;) link, err := s.chat.GenerateConnectionDeepLink(chat.ConnectionConfig{ Expiry: time.Minute * 5, // this is required ? }) let link = sdk.chat().generateConnectionDeepLink(&quot;&quot;) Subscribing to new connections # Register an observer for a connection response @app.chat.on_connection do |res| if res.status == &quot;accepted&quot; p &quot;successfully connected&quot; @app.chat.message(res.from, &quot;Hey there! We're connected!&quot;) end end s.chat.OnConnection(func(iss, status string) { log.Println(&quot;Response received from &quot; + iss + &quot; with status &quot; + status) parts := strings.Split(iss, &quot;:&quot;) s.chat.Message([]string{parts[0]}, &quot;Hi there!&quot;) }) sdk.chat().onConnection((res: any): any =&gt; { sdk.logger.info(`connection request ${res.status} by ${res.data.display_name}(${res.iss})`) sdk.chat().message(res.iss, &quot;hi there!&quot;) exit() }) </p><p>connection</p><p>connect</p><p>qr</p>",url:"https://docs.joinself.com/sdk/directconnection/"},{value:"Dynamic link",label:"<p></p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>",url:"https://docs.joinself.com/sdk/facts/dynamic_link/"},{value:"Voice Calls",label:`<p>The Voice library is a subset of helpers to allow your app to act as proxy between two connected users.
Voice call negotiation at self follow a workflow like this:
start starting messages instruct an identity to start a call with the issuer of the message using the same cid. accept the voice call has been accepted by the recipient, who responds with the details to start the voice call. busy notifies call issuer the recipient is busy and cannot answer the call. stop notifies the call has been ended by one of the users. SDK helpers SDKs provide helpers to subscribe and send all voice negotiation messages, so you can build things like a calling proxy. Let&rsquo;s see an example on how you could build a proxy.
@voice = client.Voice() @voice.on_start do |issuer, payload| call = Call.find_by(cid: payload[:cid]) customer = call.connection operator = call.user puts &quot;[voice_proxy] received start from #{issuer}, redirecting...&quot; @voice.start customer.selfid, payload[:cid], payload[:call_id], payload[:peer_info], { operator_name: operator.name } end @voice.on_accept do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user puts &amp;quot;[voice_proxy] received acceptation from #{issuer}, redirecting...&amp;quot; @voice.accept operator.selfid, payload[:cid], payload[:call_id], payload[:peer_info] end @voice.on_stop do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user if issuer == operator.selfid puts &amp;quot;[voice_proxy] received stop from #{issuer}, redirecting to operator&amp;quot; @voice.stop customer.selfid, payload[:cid], payload[:call_id] else puts &amp;quot;[voice_proxy] received stop from #{issuer}, redirecting to customer&amp;quot; @voice.stop operator.selfid, payload[:cid], payload[:call_id] end end @voice.on_busy do |issuer, payload| call = Call.find_by(cid: payload[:cid]) next if call.nil? customer = call.connection operator = call.user puts &amp;quot;[voice_proxy] received busy from #{issuer}, redirecting...&amp;quot; if issuer == operator.selfid @voice.busy customer.selfid, payload[:cid], payload[:call_id] else @voice.busy operator.selfid, payload[:cid], payload[:call_id] end end voice := client.Voice() operator := &quot;1112223334&quot; customer := &quot;1111111111&quot; voice.OnStart(func(iss, cid, callID, peerInfo string, data interface{}){ voice.Start(customer, cid, callID, peerInfo, map[string]string{ &amp;quot;operator_name&amp;quot;: &amp;quot;Bob&amp;quot;, }) }) voice.OnAccept(func(iss, cid, callID, peerInfo string, data interface{}){ voice.Accept(operator, cid, callID, peerInfo, map[string]interface{}) }) voice.OnStop(func(iss, cid, callID string) { if iss == operator { voice.Stop(customer, cid, callID) } else { voice.Stop(operator, cid, callID) } }) voice.OnBusy(func(iss, cid, callID string) { if iss == operator { voice.Busy(customer, cid, callID) } else { voice.Busy(operator, cid, callID) } }) let voice = client.Voice() let operator = &quot;1112223334&quot; let customer = &quot;1111111111&quot; voice.onStart((iss: string, cid: string, call_id: string, peer_info: string, data: any) =&gt; { voice.start(customer, cid, call_id, peer_info, { &quot;operator_name&quot;: &quot;Bob&quot;, }) }) voice.onAccept((iss: string, cid: string, call_id: string, peer_info: string, data: any) =&amp;gt; { voice.accept(operator, cid, call_id, peer_info, data) }) voice.onStop((iss: string, cid: string, call_id: string) =&amp;gt; { if (iss == operator) { voice.stop(customer, cid, call_id) } else { voice.stop(operator, cid, call_id) } }) voice.onBusy((iss: string, cid: string, call_id: string) =&amp;gt; { if (iss == operator) { voice.busy(customer, cid, call_id) } else { voice.busy(operator, cid, call_id) } }) </p><p>voice</p>`,url:"https://docs.joinself.com/sdk/voice/"},{value:"Joinself Docs",label:"<p></p>",url:"https://docs.joinself.com/"},{value:"QuickStart",label:"<p>Introduction Let&rsquo;s try out the Self-Quickstart app by cloning the Quickstart app on your local machine. To do this, you will need API keys which can be obtained by registering on the Self Developer Portal.\nYou have the option of obtaining credentials for two distinct environments, it is suggested to first develop and test your app on the sandbox environment, once it is stable and working as expected, you can then submit it for approval on the production environment, keep in mind that the approval process for production environment may take some time.\nEnvironments Sandbox Get started with test credentials and life-like data Production Launch your app with live credentials API Keys SELF_APP_ID Public app identifier SELF_APP_DEVICE_SECRET Private key Setting up your app Before we even get started with the code we need to have a valid Self-app credentials so the quick start can interact with the Self-network.\nThis can be done through the developer portal, if you&rsquo;re just getting started you can get those from the Sandbox Developer Portal.\nThis documentation site has a whole section describing how to create and tune your self-app for your specific needs, check it out for more detailed information. In order to prepare your app to run all the examples you should configure it properly on the portal:\nMark the app as listed Mark it as allows messaging Mark it as allows voice Additionally, you must connect to your app on your device, so you can interact with it\nQuickstart setup Once you have obtained your API keys, the next step is to execute the Self Quickstart on your local machine. The guidance provided below will assist you in duplicating the Quickstart repository, adjusting the ./examples/.env file with your own Self client ID and Sandbox secret, and ultimately, compiling and launching the application.\nThe Self-Quickstart is available in both Docker and non-Docker options. If you don&rsquo;t have Docker installed on your system, you might want to use the non-Docker version, particularly for Windows users who do not have Docker installed. However, if you already have Docker installed, it is recommended to use the Docker option as it is more straightforward and simpler to execute the Quickstart. The instructions provided below will guide you through the process of setting up the Quickstart with both Docker and non-Docker configurations.\nSetting up with Docker (Recommended) Docker is a platform and technology for building, shipping, and running distributed applications. It uses containerization, a method of packaging software in a way that ensures it runs consistently across different environments. Docker allows developers to package an application with all of its dependencies into a single container, which can then be easily deployed and run on any machine that has the Docker runtime installed. This makes it easy to manage and distribute applications, and helps ensure that the application will run consistently across different environments.\nOnce you have Docker installed, open the Docker application, and then utilize the following commands in the command line interface to set up and execute the Quickstart. In case the &lsquo;demo&rsquo; commands do not function as expected, confirm that Docker is running.\n# Notes for MacOS / Linux # Clone self-ruby-sdk $ git clone https://github.com/joinself/self-ruby-sdk.git $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env, then fill out SELF_APP_ID # and SELF_APP_DEVICE_SECRET in .env $ cp ./examples/.env.example ./examples/.env # start the container $ ./demo up # Finally run the quick start demo $ ./demo run # Notes for Windows # Clone self-ruby-sdk $ docker run -it --rm -v ${PWD}:/git alpine/git clone https://github.com/joinself/self-ruby-sdk $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env $ cp .\\examples\\.env.example .\\examples\\.env # Add SELF_APP_ID and SELF_APP_DEVICE_SECRET to .env $ notepad .\\examples\\.env # required in order to run local scripts Set-ExecutionPolicy RemoteSigned # start the container $ .\\demo.ps1 up # Finally run the quick start demo $ .\\demo.ps1 run Set-ExecutionPolicy Restricted Stop the container with ./demo down\nSetting up without Docker Self SDK comes with some dependencies on native libraries to manage encryption libself_olm and libself_omemo.\nBelow you&rsquo;ll find the instructions to get them working on your system.\nDebian/Ubuntu $ curl -O https://download.joinself.com/olm/libself-olm_0.1.17_amd64.deb $ curl -O https://download.joinself.com/omemo/libself-omemo_0.1.2_amd64.deb $ apt install libsodium-dev $ apt install ./libself-olm_0.1.17_amd64.deb ./libself-omemo_0.1.2_amd64.deb Redhat/Centos $ rpm -Uvh https://download.joinself.com/olm/libself-olm-0.1.14-1.x86_64.rpm $ rpm -Uvh https://download.joinself.com/omemo/libself-omemo-0.1.2-1.x86_64.rpm Mac (x86_64) $ brew tap joinself/crypto $ brew install libself-olm libself-omemo Mac (m1/arm64) Brew on M1 macs currently lacks environment variables needed for the sdk to find the olm and omemo libraries, so you will need to add some additional configuration to your system:\nIn your ~/.zshrc, add:\nexport C_INCLUDE_PATH=/opt/homebrew/include/ export LIBRARY_PATH=$LIBRARY_PATH:/opt/homebrew/lib You should then be able to run:\n$ source ~/.zshrc $ brew tap joinself/crypto $ brew install --build-from-source libself-olm libself-omemo Note, you may also need to create /usr/local/lib if it does not exist:\n$ sudo mkdir /usr/local/lib Setting up Quickstart # Note: If on Windows, run # git clone -c core.symlinks=true \\ # https://github.com/joinself/self-ruby-sdk.git # instead, to ensure correct symlink behavior $ git clone https://github.com/joinself/self-ruby-sdk.git $ cd self-ruby-sdk # Copy the ./examples/.env.example file to ./examples/.env, then fill out SELF_APP_ID # and SELF_APP_DEVICE_SECRET in .env $ cp ./examples/.env.example ./examples/.env # start the container $ ./demo up # Finally run the quick start demo $ ./demo run Use the powershell script ./demo.ps1 instead of demo if you&rsquo;re running Windows.\nPlaying with the examples When you run the demo script for the first time, you&rsquo;ll be presented with a tty interface where you&rsquo;ll be able to test all the examples.\nNote you can modify any examples under the examples.\nThe script will be displaying you information about each of the features you&rsquo;re running and pointing you to the specific documentation on this site.\n</p>",url:"https://docs.joinself.com/quickstart/"},{value:"SDK Reference",label:`<p>Self SDKs are divided on different services, each service matches one of the products Self is offering.
Setup Setting up your client Initialize Disconnect Messaging Interacting with users through chat Send Receive Mark as read Mark as received Edit Delete Groups Interacting with users through chat Create Messaging Add users Remove users Objects Interacting with users through chat Attach a public object Attach non public objects Process incoming objects Document signature Interacting with users through chat Signing a plain text Signing an object Authentication Interacting with users through chat Request Request modifiers Response QR Dynamic Links Facts Interacting with users through chat Request Request modifiers Response Custom facts Recurrent Auth combination QR Dynamic Links Connections Interacting with users through chat Permit Revoke List Voice Calls Interacting with users through chat Start Accept Busy Stop Connection Interacting with users through chat Generating a QR code Generating a dynamic link Subscribing to new connections SDK Access To build an app on self-network its required to have our app installed so you can log in to the Self Developer Portal (production or sandbox).
SDK Host When you start playing with Self you likely want to use Sandbox environment environment, as it&rsquo;s easier to setup and less restrictive.
Please visit the Sandbox documentation page to download our mobile client from app stores.
Platform status and incidents Project status page is available at status.joinself.com
Client libraries Self offers official SDK libraries for different programming languages, which are regularly updated for breaking and non-breaking changes.
Ruby SDK GO SDK Typescript SDK Rust SDK </p>`,url:"https://docs.joinself.com/sdk/"},{value:"Categories",label:"<p></p>",url:"https://docs.joinself.com/categories/"},{value:"Tags",label:"<p></p>",url:"https://docs.joinself.com/tags/"}];$("#search").autocomplete({source:e}).data("ui-autocomplete")._renderItem=function(e,t){return $("<li>").append("<a href="+t.url+' + " &quot;" +  >'+t.value+"</a>"+t.label).appendTo(e)}})</script></div></div></div></div></header><section class=section><div class=container><div class="row justify-content-center"><div class="col-lg-4 col-sm-6 mb-4"><a href=/quickstart class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-rocket icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Quickstart</h3><p class=mb-0>Learn about Self's key concepts and run a starter code</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=/sdk class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-ruler-alt-2 icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">SDK Reference</h3><p class=mb-0>Explore client-side SDK libraries and integrate with your product.</p></a></div></div></div></section><section class=section><div class=container><div class="row justify-content-center"><div class="col-12 text-center"><h2 class=section-title>Explore by Product</h2></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/authentication/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-lock icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Authentication</h3><p class=mb-0>Primary & Multi-factor authentication</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/facts/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-files icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Facts</h3><p class=mb-0>Request access to user&rsquo;s sensible data</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/messaging/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-comment icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Messaging</h3><p class=mb-0>Interact with your users through messaging</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/zero/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-shield icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Zero-knowledge</h3><p class=mb-0>Check users facts without accessing sensible data</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/documentsign/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-check-box icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Document sign</h3><p class=mb-0>Request document signatures</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/directconnection/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-plug icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">App direct connection</h3><p class=mb-0>Allow your customers to easily connect your app.</p></a></div><div class="col-lg-4 col-sm-6 mb-4"><a href=https://docs.joinself.com/sdk/voice/ class="px-4 py-5 bg-white shadow text-center d-block match-height"><i class="ti-headphone-alt icon text-primary d-block mb-4"></i><h3 class="mb-3 mt-0">Voice Calls</h3><p class=mb-0>Interact with voice call negotiation between users.</p></a></div></div></div></section><section><div class=container><div class=row><div class=col-12><div class="section px-3 bg-white shadow text-center"><h2 class=mb-4>Didn&rsquo;t find an answer to your question?</h2><p class=mb-4>Want to know how the Self Network can solve problems specific to your business?</p><a href=https://www.joinself.com/contact-us class="btn btn-primary">contact us</a></div></div></div></div></section><footer class="section pb-4"><div class=container><div class="row align-items-center"><div class="col-md-8 text-md-left text-center"><p class="mb-md-0 mb-4"></p></div><div class="col-md-4 text-md-right text-center"><ul class=list-inline><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://twitter.com/futureoftrust aria-label=Twitter><i class=ti-twitter-alt></i></a></li><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://github.com/joinself/ aria-label=Github><i class=ti-github></i></a></li><li class=list-inline-item><a class="text-color d-inline-block p-2" href=https://www.linkedin.com/company/joinself/ aria-label=Linkedin><i class=ti-linkedin></i></a></li></ul></div></div></div></footer><style>.form-control{border-radius:10px!important}.banner{background-color:#0e1c42!important}.overlay::before{opacity:0!important}.bg-cover{background-size:contain;background-position:100%}</style><script src=https://docs.joinself.com/js/script.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js></script>
<script>function setCookie(e,t,n){var s=new Date;s.setTime(s.getTime()+n*24*60*60*1e3),document.cookie=e+"="+t+";path=/;expires="+s.toUTCString()}function getCookie(e){var t=document.cookie.match("(^|;) ?"+e+"=([^;]*)(;|$)");return t?t[2]:null}function defaultPageTabs(e){let n=$(".code-tabs");for(var t=0;t<n.length;t++)$(n[t]).find(".active").removeClass("active"),tab=$(n[t]).find(".tab-pane").eq(e),$(tab).addClass("active"),tabHeader=$(n[t]).find(".nav-item").eq(e),$(tabHeader).addClass("active")}$("document").ready(function(){hljs.highlightAll(),mermaid.initialize({startOnLoad:!0}),$(".nav-tabs a").click(function(){var n=$(this).parent(),t=n.index();defaultPageTabs(t),setCookie("tabIndex",t,200)}),tabIndex=getCookie("tabIndex"),tabIndex!=null&&defaultPageTabs(tabIndex)})</script><link rel=stylesheet href=/css/styles.css></body></html>