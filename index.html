<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<title>Joinself Docs</title>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=generator content="Hugo 0.92.1">
<meta name=description content="Joinself Docs - Joinself - Platform Documentation ">
<link rel=stylesheet href=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.css>
<link rel=stylesheet href=https://docs.joinself.com/plugins/themify-icons/themify-icons.css>
<link rel=icon href=https://docs.joinself.com/images/favicon.png type=image/x-icon>
<link href="https://fonts.googleapis.com/css?family=Barlow:300,400,700&display=swap" rel=stylesheet>
<script src=https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.js></script>
<style>:root{--primary-color:#0e1c42;--body-color:#f9f9f9;--text-color:#636363;--text-color-dark:#0e1c42;--white-color:#ffffff;--light-color:#f8f9fa;--font-family:Barlow}</style>
<link href=https://docs.joinself.com/css/style.min.css rel=stylesheet media=screen>
<script src=https://docs.joinself.com/plugins/jquery/jquery-1.12.4.js></script>
<script src=https://docs.joinself.com/plugins/jquery/jquery-ui.js></script>
<script src=https://docs.joinself.com/plugins/bootstrap/bootstrap.min.js></script>
<script src=https://docs.joinself.com/plugins/match-height/jquery.matchHeight-min.js></script>
<meta property="og:image" content="https://docs.joinself.com/images/logo.png">
<meta property="og:image:width" content="57">
<meta property="og:image:height" content="35">
<meta property="og:image:type" content="image/png">
<meta name=twitter:title content="Joinself Docs">
<meta name=twitter:description content="Joinself - Platform Documentation">
<meta property="og:title" content="Joinself Docs">
<meta property="og:description" content="Joinself - Platform Documentation">
<meta property="og:type" content="website">
<meta property="og:url" content="https://docs.joinself.com/">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Joinself Docs">
<meta name=twitter:description content="Joinself - Platform Documentation">
</head>
<body>
<header class="banner overlay bg-cover" data-background=https://assets.website-files.com/5f93d989df86cd3e82710c38/5fcf94534da2634c0591391b_homepage%20people_1.png>
<nav class="navbar navbar-expand-md navbar-dark">
<div class="container px-2 px-md-0">
<a class="navbar-brand px-2" href=/>
<img class=img-fluid src=https://docs.joinself.com/images/logo_white.png alt="Joinself - Platform Documentation">
</a>
<button class="navbar-toggler border-0" type=button data-toggle=collapse data-target=#navigation aria-controls=navigation aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse text-center" id=navigation>
<ul class="navbar-nav ml-auto">
<li class=nav-item>
<a class="nav-link text-dark" href=https://docs.joinself.com/>Home</a>
</li>
<li class=nav-item>
<a class="nav-link text-dark" href=https://www.joinself.com/faq>Faq</a>
</li>
<li class=nav-item>
<a class="nav-link text-dark" href=https://www.joinself.com/contact-us>contact</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle text-dark" href=# role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
docs
</a>
<div class=dropdown-menu>
<a class=dropdown-item href=https://docs.joinself.com/setup/>Setup</a>
<a class=dropdown-item href=https://docs.joinself.com/users/>Users</a>
<a class=dropdown-item href=https://docs.joinself.com/messaging/>Messaging</a>
<a class=dropdown-item href=https://docs.joinself.com/authentication/>Authentication</a>
<a class=dropdown-item href=https://docs.joinself.com/facts/>Facts</a>
<a class=dropdown-item href=https://docs.joinself.com/zero/>Zero-knowledge</a>
<a class=dropdown-item href=https://docs.joinself.com/notify/>Notify</a>
</div>
</li>
</ul>
</div>
</div>
</nav>
<div class="container section">
<div class=row>
<div class="col-lg-8 text-center mx-auto">
<h1 class="text-white mb-3">
Platform Documentation
</h1>
<p class="text-white mb-4">
Here you&rsquo;ll find handy documentation about our APIs and SDKs
</p>
<div class=position-relative>
<input id=search class=form-control placeholder="Have a question? Just ask here or enter terms">
<i class="ti-search search-icon"></i>
<script>$(function(){var a=[{value:"Blocking requests",label:"<p>\r\rfacts = [{ sources: [SelfSDK::SOURCE_USER_SPECIFIED], fact: SelfSDK::FACT_EMAIL, operator: \u0027==\u0027, expected_value: \u0027test@test.org\u0027 }] res = @client.facts.request_via_intermediary(selfid, facts) # GOTO Receiving fact response - Deal with the response   req := fact.IntermediaryFactRequest{ SelfID: selfID, Intermediary: intermediary, Description: \u0026quot;info\u0026quot;, Facts: []fact.Fact{ { Fact: fact.FactDateOfBirth, Sources: []string{fact.SourceUserSpecified}, Operator: \u0026quot;\u0026gt;=\u0026quot;, ExpectedValue: time.Now().Format(time.RFC3339), }, }, Expiry: time.Minute * 5, } resp, err := client.FactService().RequestViaIntermediary(\u0026amp;req) \n try { let res = await sdk.facts().requestViaIntermediary(selfID, [{ fact: \u0027phone_number\u0027, operator: \u0027==\u0027, sources: [\u0027user_specified\u0027], expected_value: \u0027\u002b44111222333\u0027 }]) if(!res) { sdk.logger.warn(`fact request has timed out`) } else if(res.status === \u0026quot;unauthorized\u0026quot;) { sdk.logger.warn(\u0026quot;you are unauthorized to run this action\u0026quot;) } else if (res.status === \u0027accepted\u0027) { sdk.logger.info(\u0026quot;your assertion is....\u0026quot;) sdk.logger.info(res.attestationValuesFor(\u0027phone_number\u0027)[0]) } else { sdk.logger.info(\u0026quot;your request has been rejected\u0026quot;) } } catch (error) { sdk.logger.error(error.toString()) }   \r </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>blocking</p>",url:"https://docs.joinself.com/zero/blocking/"},{value:"Send and receive messages",label:"<p>Self SDK allows you to send messages to any identity on self network, this includes users, orgs and apps.\nThe interface used to interact with messaging is chat service, let\u0026rsquo;s see how can we create an app automatically responding all ping messages with a pong.\n\r@app.chat.on_message do |msg| if msg.body == \u0026quot;ping msg.message \u0026quot;pong\u0026quot; end end @app.chat.message user, \u0026quot;ready!\u0026quot;   client.ChatService().OnMessage(func(cm *chat.Message) { if cm.Body == \u0026quot;ping\u0026quot; { cm.Message(\u0026quot;pong\u0026quot;) } }) @app.chat.message user, \u0026quot;ready!\u0026quot;   sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { if (cm.body == \u0026quot;ping\u0026quot;) { cm.message(\u0026quot;pong\u0026quot;) } }) @app.chat.message user, \u0026quot;ready!\u0026quot;   \r Easy, isn\u0026rsquo;t it? As you can see, you can use the chat service message method to send messages to a specific user, and on_message to receive them.\nThe object representing a message has also some handy methods to interact with that message, included sending a new message to the same conversation with message(body).\nLet\u0026rsquo;s have a closer look at all the options you have when sending and receiving messages\nSending messages The interface for sending a normal message is quite simple, just provide the user and text you want to send and that\u0026rsquo;s it.\nHowever, the system provides some useful options you can pass to this method. Let\u0026rsquo;s have a look at the most important ones.\n\r@app.chat.message user, \u0026quot;ready!\u0026quot;, gid: \u0026quot;group_id\u0026quot;, rid: \u0026quot;uuid\u0026quot;,   client.ChatService().Message(user, \u0026quot;ready!\u0026quot;, chat.MessageOptions{ GID: \u0026quot;group_id\u0026quot;, RID: \u0026quot;uuid, }   client.chat().message user, \u0026quot;ready!\u0026quot;, { \u0026quot;gid\u0026quot;: \u0026quot;group_id\u0026quot;, \u0026quot;rid\u0026quot;: \u0026quot;uuid\u0026quot; }   \r gid You\u0026rsquo;ll see gid option supported across different methods, gid refers to group id, and when provided will indicate the other client the current conversation is a group conversation instead of a 1 to 1 chat.\nUsually this id is not used directly through this method, and instead the message is sent through a helper on Group object, check Groups for more details.\nrid In this case rid is used to refer a previous message by it\u0026rsquo;s jti, once the other party receives a rid as part of the payload it will interpret is a direct response to a specific message, and it will be displayed accordingly.\nIf you\u0026rsquo;ve already received a message you want to respond, you can do it directly through the respond method like:\n\r@app.chat.on_message do |msg| msg.respond \u0026quot;I like this\u0026quot; end   client.ChatService().OnMessage(func(cm *chat.Message) { cm.Respond(\u0026quot;I like this\u0026quot;) })   sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { cm.respond(\u0026quot;I like this\u0026quot;) })   \r </p><p>messaging</p><p>message</p><p>messages</p>",url:"https://docs.joinself.com/messaging/text-messages/"},{value:"Blocking auth requests",label:"<p>This approach sends an authentication request and waits for the user to respond before continuing the execution.\nThis approach is useful when you want to wait for a user to respond to the authentication before continuing, and you don’t have timeout limitations on your server. An example could be authenticating a user on your command line script.\nLets see how it works, the functions below show a full cycle for a blocking authentication.\n\rbegin\r@app.authentication.request(\u0026quot;1112223334\u0026quot;).accepted?\rrescue =\u0026gt; e # An exception will be raised in case of a timeout or internal error\rreturn false\rend\r \rresp, err != client.AuthenticationService().Request(\u0026quot;1112223334\u0026quot;)\rif err != nil {\rprintln(\u0026quot;authentication rejected\u0026quot;)\rreturn\r}\rprintln(resp.Accepted)\r \rtry {\rlet res = await client.authentication().request(\u0026quot;1112223334\u0026quot;)\rif(res.isAccepted() == true) {\rclient.logger.info(`${res.selfID} is now authenticated 🤘`)\r} else if(res.accepted == false) {\rclient.logger.warn(`${res.selfID} has rejected your authentication request`)\r} else {\rclient.logger.error(res.errorMessage)\r}\r} catch (error) {\rclient.logger.error(error.toString())\r}\r \r\r </p><p></p>",url:"https://docs.joinself.com/authentication/blocking/"},{value:"Blocking fact request",label:"<p>Same as with authentication there are situations where you want to block your execution line until the user responds to your fact request. For example, you may want to block a user\u0026rsquo;s access to a certain space of your site until you verify its passport number.\nThis function blocks the execution line until the user responds with its verified email address.\n\r def get_email(selfid)\rres = @client.facts.request(selfid, [:email_address])\rreturn \u0026quot;\u0026quot; unless res.accepted?\rres.attestation_values_for(:email_address).first\r// Refer to Receiving fact response - Deal with request for more info\rrescue =\u0026gt; e // An exception will be raised in case of a timeout or internal error\rreturn \u0026quot;\u0026quot;\rend\r \rreq := fact.FactRequest{\rSelfID: selfID,\rDescription: \u0026quot;info\u0026quot;,\rFacts: []fact.Fact{{ Fact: fact.FactEmail }},\rExpiry: time.Minute * 5,\r}\rresp, err := client.FactService().Request(\u0026amp;req) if err != nil { return \u0026quot;\u0026quot;, err }\naa, err := resp.AttestaionValuesFor(fact.FactEmail) if err != nil { return \u0026quot;\u0026quot;, err }\nprintln(aa[0]) \n\rtry {\rlet res = await sdk.facts().request(selfID, [{ fact: \u0027email_address\u0027 }])\rif (!res) {\rsdk.logger.warn(`fact request has timed out`)\r} else if (res.status === \u0027accepted\u0027) {\rlet pn = res.attestationValuesFor(\u0027email_address\u0027)[0]\rsdk.logger.info(`${selfID} email address is \u0026amp;quot;${pn}\u0026amp;quot;`)\r} else {\rsdk.logger.warn(`${selfID} has rejected your authentication request`)\r}\r } catch (error) { sdk.logger.error(error.toString()) } \n\r\r </p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>blocking</p>",url:"https://docs.joinself.com/facts/blocking/"},{value:"Connections",label:"<p>Permit connections Allows incoming messages from specified identities.\n\r@client.messaging.permit_connection \u0026quot;1234567890\u0026quot;   err := selfsdk.MessagingService().PermitConnection(\u0026quot;1234567890\u0026quot;)   let success = await sdk.messaging().permitConnection(\u0026quot;1234567890\u0026quot;)   \r Permitting incomming connections only applies if you don\u0026rsquo;t have a global connection (*) permission. If you do, you have to revoke it first.\n Permit global connections You can permit connections from everyone using an “*”.\n\r@client.messaging.permit_connection \u0026quot;*\u0026quot;   err := selfsdk.MessagingService().PermitConnection(\u0026quot;*\u0026quot;)   let success = await sdk.messaging().permitConnection(\u0026quot;*\u0026quot;)   \r Revoke specific connection You can also revoke connections from a specific self identifier with:\n\r@client.messaging.revoke_connection \u0026quot;1234567890\u0026quot;   err := client.MessagingService().RevokeConnection(\u0026quot;1234567890\u0026quot;)   let success = await sdk.messaging().revokeConnection(\u0026quot;1234567890\u0026quot;)   \r Revoking a connection only applies if you don\u0026rsquo;t have a global connection (*) permission setup. If you do, you have to revoke it first.\n Revoke global connections Revoke connection permissions from everyone using an “*”.\n\r@client.messaging.revoke_connection \u0026quot;*\u0026quot;   err := client.MessagingService().RevokeConnection(\u0026quot;*\u0026quot;)   let success = await sdk.messaging().revokeConnection(\u0026quot;*\u0026quot;)   \r Listing connections You can list your app allowed connections.\n\r@client.messaging.allowed_connections.each do |self_id| p \u0026quot;- \u0027#{self_id}\u0027\u0026quot; end   connections, _ := client.MessagingService().ListConnections() log.Println(\u0026quot;connected to:\u0026quot;, connections)   conns = await sdk.messaging().allowedConnections() sdk.logger.info(` - connections : ${conns.join(\u0026quot;,\u0026quot;)}`)   \r </p><p>identity</p><p>app</p><p>connect</p><p>disconnect</p><p>permit</p><p>block</p>",url:"https://docs.joinself.com/users/connections/"},{value:"Non-blocking fact request",label:"<p>The sdk also allows us to send a fact request without blocking the execution line.\nSame registration example we used for authentication works here, if you want to get a user verified fact but you don’t want the user to be blocked on the registration form, you can use this approach to continue with the execution line, and process the response as soon as it gets back.\nLet’s see how we can request a verified email address with a non-blocking request.\n\r def get_email_in_background(selfid)\r@client.facts.request(user, [:email_address]) do |res|\rreturn \u0026quot;\u0026quot; unless res.accepted?\rreturn res.attestation_values_for(:email_address).first\r# Refer to Receiving fact response - Deal with request for more info\rend\rrescue =\u0026gt; e # An exception will be raised in case of a timeout or internal error\rreturn \u0026quot;\u0026quot;\rend\r \r// Use goroutines to build a non-blocking example based on the blocking one\rgo func() {\rreq := fact.FactRequest{\rSelfID: selfID,\rDescription: \u0026quot;info\u0026quot;,\rFacts: []fact.Fact{{ Fact: fact.FactEmail }},\rExpiry: time.Minute * 5,\r}\rresp, err := client.FactService().Request(\u0026amp;amp;req)\rif err != nil {\rreturn \u0026amp;quot;\u0026amp;quot;, err\r}\raa, err := resp.AttestaionValuesFor(fact.FactEmail)\rif err != nil {\rreturn \u0026amp;quot;\u0026amp;quot;, err\r}\rprintln(aa[0])\r if err != nil { // failed } // do something with email } \n\rasync() =\u0026gt; {\rtry {\rlet res = await sdk.facts().request(selfID, [{ fact: \u0027email_address\u0027 }])\rif (!res) {\rsdk.logger.warn(`fact request has timed out`)\r} else if (res.status === \u0027accepted\u0027) {\rlet pn = res.attestationValuesFor(\u0027email_address\u0027)[0]\rsdk.logger.info(`${selfID} email address is \u0026amp;quot;${pn}\u0026amp;quot;`)\r} else {\rsdk.logger.warn(`${selfID} has rejected your authentication request`)\r}\r } catch (error) { sdk.logger.error(error.toString()) } } \n\r\r </p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>non-blocking</p>",url:"https://docs.joinself.com/facts/non-blocking/"},{value:"Message actions",label:"<p>In this section we will review what actions we can take to modify the message state.\nMark as received When your app receives a message the sdk is marking it as received by default. This behavior can be changed by modifying passing a specific parameter to on_message, at the same time you can mark a message as read on your convenience, let\u0026rsquo;s see how.\n\r@app.chat.on_message mark_as_delivered: false do |msg| msg.mark_as_delivered # explicitly mark the message as delivered end   client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsDelivered() }, chat.OnMessageOptions{ MarkAsDelivered: false })   sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { cm.markAsDelivered() }, { \u0027mark_as_delivered\u0027: false })   \r Default behavior for on_message is to mark the message as received as soon as it\u0026rsquo;s received.\n Mark as read Similarly to the previous example, you can modify on_message to automatically mark all messages as read with a specific option.\n\r@app.chat.on_message mark_as_read: true do |msg| # ... end   client.ChatService().OnMessage(func(cm *chat.Message) { // ... }, chat.OnMessageOptions{ MarkAsRead: true })   sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { // ... }, { \u0027mark_as_read\u0027: true })   \r Additionally you can explicitly mark a received message as read with your own logic.\n\r@app.chat.on_message do |msg| msg.mark_as_read end   client.ChatService().OnMessage(func(cm *chat.Message) { cm.MarkAsRead() })   sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { cm.MarkAsRead() })   \r Edit For a message you\u0026rsquo;ve already sent you can modify its body.\n\rm = @app.chat.message user, \u0026quot;one\u0026quot; m.edit \u0026quot;two\u0026quot;   m := @app.chat.message user, \u0026quot;one\u0026quot; m.Edit(\u0026quot;two\u0026quot;)   let m = @app.chat.message user, \u0026quot;one\u0026quot; m.Edit(\u0026quot;two\u0026quot;)   \r You\u0026rsquo;re only allowed to modify your own messages.\n Delete Deleting a message is as simple as modifying it, but using delete method instead.\n\rm = @app.chat.message user, \u0026quot;one\u0026quot; m.delete   m := @app.chat.message user, \u0026quot;one\u0026quot; m.Delete()   let m = @app.chat.message user, \u0026quot;one\u0026quot; m.Delete()   \r You\u0026rsquo;re only allowed to delete your own messages.\n </p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>",url:"https://docs.joinself.com/messaging/actions/"},{value:"Non-blocking requests",label:"<p>\r\r@client.facts.request_via_intermediary(selfid, facts) do |res| # GOTO Receiving fact response - Deal with the response end   // use language built in goroutines go func() { // ... }   // use language built in async async() =\u0026gt; { // ... }   \r </p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>non-blocking</p>",url:"https://docs.joinself.com/zero/non-blocking/"},{value:"Getting started",label:"<p>Requirements To build an app on self-network its required to have our app installed so you can log in to the Self Developer Portal.\nPlease visit the official app stores to download our official apps for Android and iOS\nCreate an account Visit Self Developer Portal and follow the steps to register. You\u0026rsquo;ll need a Self Identifier account to proceed.\nApp creation Self-apps are autonomous self identities able to interact with other identities on the Self-network.\nA developer can create an app through the developer portal. This app will be identified by a SELF_APP_ID and a SELF_APP_DEVICE_SECRET.\nSELF_APP_ID is your public identifier on the network and you can share it with other peers. You must keep SELF_APP_DEVICE_SECRET in a secure place.\nYou’ll see below how to use these two strings to initialize your client and start interacting with the Self-network.\nRemember — copy and store SELF_APP_DEVICE_SECRET, as we don\u0026rsquo;t have access to it.\n Environments Self provides a sandbox so you can try your app code before moving to production. You can register for a free developer account and create new test apps on the Sandbox developer portal here.\nOnce your app is ready you can create a new one on production here\n</p><p>setup</p><p>configuration</p><p>requirements</p>",url:"https://docs.joinself.com/setup/getting-started/"},{value:"Identity types",label:"<p>Self network is formed of different entities with the ability to interact between them.\nWe name these entities identities and they own a self_id, an array of device ids and an array of public keys.\nAn identity can only communicate with another identity if IdentityA is a connection of IdentityB. If this connection is in place IdentityA will be able to request the IdentityB properties (device_ids and public keys) to interact with it.\nAt the moment identities can be divided into users and apps.\nGetting the public keys Every single identity on the Self network has at least one public key assigned to it. Lets see how you can get the public keys related to a Self user.\n\r@user = @client.identity.public_key \u0026quot;1112223334\u0026quot;, \u0026quot;1\u0026quot;   identity, _ := client.IdentityService().GetPublicKey(\u0026quot;1112223334\u0026quot;, \u0026quot;1\u0026quot;)   let key = await client.identity().publicKey(\u0026quot;1112223334\u0026quot;, \u0026quot;1\u0026quot;)   \r Identity devices Same as with public keys each identity has at least one device.\n\r@devices = @client.identity.devices \u0026quot;1112223334\u0026quot;   devices _ := client.IdentityService().GetDevices(\u0026quot;1112223334\u0026quot;)   let devices = await client.identity().devices(\u0026quot;1112223334\u0026quot;)   \r </p><p>identity</p><p>app</p><p>public keys</p><p>devices</p>",url:"https://docs.joinself.com/users/identity-types/"},{value:"Non-blocking auth requests",label:"<p>In contrast to blocking auth requests, there are situations where you just want to continue your execution line and set up an observer to be executed as soon as a response is received.\nLet\u0026rsquo;s say you have a conventional registration process where you let your users register to your application by its email address but you delay the email confirmation until they get back to you. This allows your users to go through a quick registration process, while you delay the data confirmation process.\n\r# Request lets you pass a block to be executed once a response is received\r@client.authentication.request selfid do |auth|\rreturn auth.accepted? # The user has rejected the authentication\rend\r \r// Go language provides you with goroutines to\r// implement a non-blocking approach\rgo func() {\rres, err != client.AuthenticationService().Request(selfid)\rif err != nil {\rprintln(\u0026quot;authentication rejected\u0026quot;)\rreturn\r}\rprintln(res.Accepted)\r}()\r \rasync() =\u0026gt; {\rtry {\rlet res = await client.authentication().request(\u0026quot;1112223334\u0026quot;)\rif(res.isAccepted() == true) {\rclient.logger.info(`${res.selfID} is now authenticated 🤘`)\r} else if(res.accepted == false) {\rclient.logger.warn(`${res.selfID} has rejected your authentication request`)\r} else {\rclient.logger.error(res.errorMessage)\r}\r} catch (error) {\rclient.logger.error(error.toString())\r}\r}\r \r\r </p><p></p>",url:"https://docs.joinself.com/authentication/non-blocking/"},{value:"System dependencies",label:"<p>Self SDK depends on some native libraries to manage encryption libself_olm and libself_omemo. Below you\u0026rsquo;ll find the instructions to get them working on your system.\nDebian/Ubuntu $ curl -O https://download.joinself.com/olm/libself-olm_0.1.17_amd64.deb $ curl -O https://download.joinself.com/omemo/libself-omemo_0.1.2_amd64.deb $ apt install libsodium-dev $ apt install ./libself-olm_0.1.17_amd64.deb ./libself-omemo_0.1.2_amd64.deb Redhat/Centos $ rpm -Uvh https://download.joinself.com/olm/libself-olm-0.1.14-1.x86_64.rpm $ rpm -Uvh https://download.joinself.com/omemo/libself-omemo-0.1.2-1.x86_64.rpm Mac (x86_64) $ brew tap joinself/crypto $ brew install libself-olm libself-omemo Mac (m1/arm64) Brew on M1 macs currently lacks environment variables needed for the sdk to find the olm and omemo libraries, so you will need to add some additional configuration to your system:\nIn your ~/.zshrc, add:\nexport C_INCLUDE_PATH=/opt/homebrew/include/ export LIBRARY_PATH=$LIBRARY_PATH:/opt/homebrew/lib You should then be able to run:\n$ source ~/.zshrc $ brew tap joinself/crypto $ brew install --build-from-source libself-olm libself-omemo Note, you may also need to create /usr/local/lib if it does not exist:\n$ sudo mkdir /usr/local/lib </p><p>setup</p><p>configuration</p><p>requirements</p>",url:"https://docs.joinself.com/setup/dependencies/"},{value:"Asynchronous",label:"<p>\r\rres = @client.facts.request_via_intermediary(selfid, facts, async: true)   req := fact.IntermediaryFactRequest{ SelfID: os.Args[1], Intermediary: intermediary, Description: \u0026quot;info\u0026quot;, Facts: []fact.Fact{ { Fact: fact.FactEmail, Sources: []string{fact.SourceUserSpecified}, Operator: \u0026quot;==\u0026quot;, ExpectedValue: \u0026quot;test@example.com\u0026quot;, }, }, Expiry: time.Minute * 5, } factService := client.FactService()\nresp, err := factService.RequestViaIntermediary(\u0026amp;req) if err != nil { log.Fatal(\u0026quot;fact request returned with: \u0026quot;, err) }\nfor _, f := range resp.Facts { if f.Result() != true { log.Fatal(\u0026quot;intermediary could not verify the required facts\u0026quot;) } log.Printf(\u0026quot;Your assertion that %s %s is %t\\n\u0026quot;, f.Fact, f.Operator, f.Result()) } \n let res = await sdk.facts().requestViaIntermediary(selfID, facts, { \u0027async\u0027: true }   \r This will return a conversation id identifying the fact request conversation, you should store it and catch it on a subscription, as described on the next section.\n</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>async</p>",url:"https://docs.joinself.com/zero/async/"},{value:"Group management",label:"<p>Managing group conversations is something really simple with Self SDK, let\u0026rsquo;s see an end to end example to understand how they work.\n\r@groups = {} @app.chat.on_invite do |group| @groups[group.gid] = group group.join group.message(\u0026quot;hi\u0026quot;) end @app.chat.on_join do |msg| @groups[msg[:gid]].members \u0026lt;\u0026lt; msg[:iss] end @app.chat.on_leave do |msg| @groups[msg[:gid]].members.delete(msg[:iss]) end @app.chat.on_message do |msg| return if msg.gid.nil? puts \u0026quot;[#{@groups[msg.gid].name}] #{msg.from}: #{msg.body}\u0026quot; end   groups := make(map[string]*chat.Group, 0) chat.ChatService().OnInvite(func(g *chat.Group) { g.Join() groups[g.GID] = g g.Message(\u0026quot;hey!\u0026quot;) }) cs.OnLeave(func(iss, gid string) { delete(groups, gid) }) chat.ChatService().OnJoin(func(iss, gid string) { if _, ok := groups[gid]; ok { groups[gid].Members = append(groups[gid].Members, iss) } }) chat.ChatService().OnMessage(func(cm *chat.Message) { if len(cm.GID) == 0 { return } fmt.Printf(\u0026quot;[%s] %s: %s\u0026quot;, groups[cm.GID].Name, cm.Iss, cm.Body) })   let groups = {} sdk.chat().onInvite(async (g: ChatGroup) =\u0026gt; { g.join() groups[g.gid] = g await groups[g.gid].message(\u0026quot;hey!\u0026quot;) }) sdk.chat().onJoin(async (iss: string, gid: string) =\u0026gt; { groups[gid].members.push(iss) }) sdk.chat().onLeave(async (iss: string, gid: string) =\u0026gt; { delete groups[gid].members[iss] }) sdk.chat().OnMessage(async (cm: ChatMessage) =\u0026gt; { if (len(cm.gid) \u0026gt; 0) { console.log(`[${groups[cm.gid].name}] ${cm.iss}: ${cm.body}`) } })   \r As you can see this example manages every group incoming message, to keep an in memory updated list of groups with its members.\nCreating a group Your app is als also able to create a group by calling invite method. \rmembers = [user1, user2, user3] @app.chat.invite \u0026quot;my_gid\u0026quot;, \u0026quot;Group name\u0026quot;, members   members = []string{user1, user2, user3} client.ChatService().Invite(\u0026quot;my_gid\u0026quot;, \u0026quot;Group name\u0026quot;, members)   let members = [user1, user2, user3] sdk.chat().Invite(\u0026quot;my_gid\u0026quot;, \u0026quot;Group name\u0026quot;, members)   \r\nHave in mind you can send messages to a newly created group, but those messages will only be delivered to the group members that have decided to join the group.\n Groups can also have an image as avatar, you can pass a file contents as parameter to chat invite to provide that image. \rmembers = [user1, user2, user3] URI.open(\u0026quot;https://www.avasflowers.net/img/prod_img/avasflowers-dreaming-of-tuscany-bouquet.jpg\u0026quot;) do |image| @groups[gid] = @app.chat.invite(gid, \u0026quot;MagicGroup\u0026quot;, members, { data: image.read, mime: \u0026quot;image/jpg\u0026quot; }) end   members = []string{user1, user2, user3} data, err := os.ReadFile(\u0026quot;/tmp/dat\u0026quot;) check(err) client.ChatService().Invite(\u0026quot;my_gid\u0026quot;, \u0026quot;Group name\u0026quot;, members, chat.InviteOptions{ Data: data, Mime: \u0026quot;image.gif\u0026quot;, })   import * as fs from \u0027fs\u0027; let data = fs.readFileSync(\u0027foo.txt\u0027,\u0027utf8\u0027); let members = [user1, user2, user3] sdk.chat().Invite(\u0026quot;my_gid\u0026quot;, \u0026quot;Group name\u0026quot;, members, { \u0026quot;data\u0026quot;: data, \u0026quot;mime\u0026quot;: \u0026quot;image/gif\u0026quot;, })   \r\nMessaging and groups Sending messages to a group is as easy as calling the message method on that group. Additionally once you receive a message on a group you will have access to all its helpers to continue the conversation without having to care about the group itself.\n</p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>read</p><p>delivered</p><p>edit</p><p>delete</p><p>remove</p>",url:"https://docs.joinself.com/messaging/groups/"},{value:"Initializing your client",label:"<p>Install your client \r$ gem install \u0026quot;selfsdk\u0026quot;   $ go get github.com/joinself/self-go-sdk   $ npm install self-sdk   \r We currently offer support for some basic clients. We are always happy to receive contributions to review - send us a PR, or contact us at info@joinself.com to share what you have built with us!\n   Language URL     Go https://github.com/joinself/self-go-sdk   Ruby https://github.com/joinself/self-ruby-sdk/   Typescript https://github.com/joinself/self-typescript-sdk/    Referencing the SDK SelfSDK is referenced like any other library for each specific language.\n\rrequire \u0026quot;selfsdk\u0026quot;   import \u0026quot;github.com/joinself/self-go-sdk\u0026quot;   import SelfSDK from \u0027self-sdk\u0027   \r Storage key generation Self-SDK locally persists session and account information needed for end to end encryption. A SELF_STORAGE_KEY is required to securely encrypt this information. It is recommended that you use a large random string for your SELF_STORAGE_KEY. You can generate a random string through the command line with:\n$ LC_ALL=C tr -dc \u0027[:alnum:]\u0027 \u0026lt; /dev/urandom | head -c64\nKeep that key in a secure place as you’ll need it to initialize a connection.\nBasic connection A basic connection to Self network only requires your SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR.\nYou may want to add SELF_APP_ID, SELF_APP_DEVICE_SECRET, SELF_STORAGE_KEY and SELF_STORAGE_DIR as environment variables.\n\r@client = SelfSDK::App.new(ENV[\u0026quot;SELF_APP_ID\u0026quot;], ENV[\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;], ENV[\u0026quot;SELF_STORAGE_KEY\u0026quot;], ENV[\u0026quot;SELF_STORAGE_DIR\u0026quot;])   client, err := selfsdk.New(selfsdk.Config{ SelfAppD: os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), SelfAppDeviceSecret: os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), StorageKey: os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), StorageDir: os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;), })   const client = await SelfSDK.build( os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;),   \r Custom environment When you’re debugging your app, you may want to point to the sandbox environment instead of production to run your tests. You can define the environment by passing additional parameters to the Self client initialization.\n\r@client = SelfSDK::App.new(ENV[\u0026quot;SELF_APP_ID\u0026quot;], ENV[\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;], ENV[\u0026quot;SELF_STORAGE_KEY\u0026quot;], ENV[\u0026quot;SELF_STORAGE_DIR\u0026quot;], environmnent: :sandbox)   client, err := selfsdk.New(selfsdk.Config{ SelfAppD: os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), SelfAppDeviceSecret: os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), StorageKey: os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), StorageDir: os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;), Environment:	\u0026quot;sandbox\u0026quot;, })   const client = await SelfSDK.build( os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;), { \u0027env\u0027: \u0027sandbox\u0027 })   \r Reconnection Self-SDK keeps a websocket connection open to self-messaging, but eventually, that connection may drop. By default Self-SDK will try to reconnect, but you can override this behaviour by passing custom parameters to initialization.\n\r@client = SelfSDK::App.new(ENV[\u0026quot;SELF_APP_ID\u0026quot;], ENV[\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;], ENV[\u0026quot;SELF_STORAGE_KEY\u0026quot;], ENV[\u0026quot;SELF_STORAGE_DIR\u0026quot;], auto_reconnect: false)   client, err := selfsdk.New(selfsdk.Config{ SelfAppD: os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), SelfAppDeviceSecret: os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), StorageKey: os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), StorageDir: os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;), ReconnectAttempts:	-1, })   const client = await SelfSDK.build( os.Getenv(\u0026quot;SELF_APP_ID\u0026quot;), os.Getenv(\u0026quot;SELF_APP_DEVICE_SECRET\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_KEY\u0026quot;), os.Getenv(\u0026quot;SELF_STORAGE_DIR\u0026quot;), { \u0027autoReconnect\u0027: false })   \r </p><p>install</p><p>setup</p><p>initialisation</p>",url:"https://docs.joinself.com/setup/initialize/"},{value:"Async auth requests",label:"<p>This scenario is similar to non-blocking authentication, however, it’s not restricted to only one user.\nSending an asynchronous authentication request is pretty straightforward, you can do it with the async option.\nThis will return a conversation id identifying the authentication conversation, you should store it and catch it on a subscription, check Receiving authentication response - Subscribe section on how to manage this.\n\rcid = @client.\rauthentication.\rrequest(\u0026quot;1112223334\u0026quot;, async: true)\r \rclient.\rAuthenticationService().\rRequestAsync(\u0026quot;1112223334\u0026quot;, \u0026quot;conversation_id\u0026quot;)\r \rlet res = await client.\rauthentication().\rrequest(\u0026quot;1112223334\u0026quot;, { \u0027async\u0027: true })\r \r\r </p><p></p>",url:"https://docs.joinself.com/authentication/async/"},{value:"Asynchronous fact request",label:"<p>The asynchronous approach can be used in scenarios like the previous one, however it has a subtle difference, you have a single observer for all information requests, which can be useful in some situations as you can have all the logic centralized on a single point.\n\rcid = @client.facts.request(selfid, [SelfSDK::FACT_EMAIL], async: true)\r \rreq := fact.FactRequest{\rSelfID: selfID,\rDescription: \u0026quot;info\u0026quot;,\rFacts: []fact.Fact{{ Fact: fact.FactEmail }},\rExpiry: time.Minute * 5,\rAsync: true,\rCID: \u0026quot;conversation_id\u0026quot;,\r}\rresp, err := client.FactService().RequestAsync(\u0026amp;req) if err != nil { return \u0026quot;\u0026quot;, err } \n\rlet res = await sdk.facts().request(selfID, [{ fact: \u0027email_address\u0027 }], { async: true })\r \r\r </p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>async</p>",url:"https://docs.joinself.com/facts/async/"},{value:"Custom auth requests",label:"<p>Providing a cid allows you to override the randomly generated conversation id with your own, this is useful to keep track of conversations with a preset identifier, let’s see the asynchronous example using a custom cid.\nInstead of using the randomly generated conversation identifier, we can force the system to use our own unique id.\n\r@client.\rauthentication.\rrequest(\u0026quot;1112223334\u0026quot;, cid: \u0026quot;conversation_id\u0026quot;)\r \rclient.\rAuthenticationService().\rRequestAsync(\u0026quot;1112223334\u0026quot;, \u0026quot;conversation_id\u0026quot;)\r \rlet res = await client.\rauthentication().\rrequest(\u0026quot;1112223334\u0026quot;, { \u0027cid\u0027: \u0026quot;conversation_id\u0026quot; })\r \r\r </p><p></p>",url:"https://docs.joinself.com/authentication/custom/"},{value:"Attachments / objects",label:"<p>Sharing an image, a document or just a gif is an important part of your users daily messaging, the SDK allows your app to send this kind of messages as well. Let\u0026rsquo;s see how.\nPublic objects Most of the time we only share public images, and in this case we don\u0026rsquo;t require the document to be encrypted, so we can directly share the URL.\n\ropts = { objects: [{ link: \u0026quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif\u0026quot;, name: \u0026quot;homer\u0026quot;, mime: \u0026quot;image/gif\u0026quot;, }] }   obj := chat.MessageObject{ Name: \u0026quot;Hello\u0026quot;, Link: \u0026quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif\u0026quot;, Mime: \u0026quot;image/gif\u0026quot;, } m, err = cs.Message([]string{os.Args[1]}, \u0026quot;no way...\u0026quot;, chat.MessageOptions{ Objects: []chat.MessageObject{obj}, })   opts = { \u0026quot;objects\u0026quot;: [{ \u0026quot;link\u0026quot;: \u0026quot;https://user-images.githubusercontent.com/14011726/94132137-7d4fc100-fe7c-11ea-8512-69f90cb65e48.gif\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;homer\u0026quot;, \u0026quot;mime\u0026quot;: \u0026quot;image/gif\u0026quot;, }]} client.chat().message user, \u0026quot;ready!\u0026quot;, opts) \n \r Non-public objects All non-public objects shared between identities are encrypted by default using Poly1305. This encryption layer is built on the SDK, so should be transparent for end users. Let\u0026rsquo;s see how we can send a local file.\n\rURI.open(path) do |image| name = \u0026quot;image.#{path.split(\u0026quot;.\u0026quot;).last}\u0026quot; mime = \u0026quot;image/#{path.split(\u0026quot;.\u0026quot;).last}\u0026quot; msg.message(\u0026quot;your image sir...\u0026quot;, objects: [{ name: name, data: image.read, mime: mime }]) end   data, err := os.ReadFile(\u0026quot;/tmp/dat\u0026quot;) check(err) m, err = cs.Message([]string{os.Args[1]}, \u0026quot;your file sir...\u0026quot;, chat.MessageOptions{ Objects: []chat.MessageObject{chat.MessageObject{ Name: \u0026quot;image.gif\u0026quot;, Data: data, Mime: \u0026quot;image/gif\u0026quot;, }}, })   import * as fs from \u0027fs\u0027; let data = fs.readFileSync(\u0027foo.txt\u0027,\u0027utf8\u0027); client.chat().message user, \u0026quot;your file sir...\u0026quot;, { \u0026quot;objects\u0026quot;: [{ \u0026quot;data\u0026quot;: data, \u0026quot;name\u0026quot;: \u0026quot;image.gif\u0026quot;, \u0026quot;mime\u0026quot;: \u0026quot;image/gif\u0026quot;, }]})   \r </p><p>messaging</p><p>message</p><p>messages</p><p>attachments</p><p>object</p><p>image</p><p>file</p>",url:"https://docs.joinself.com/messaging/objects/"},{value:"Subscribe to zero knowledge fact check",label:"<p>A subscription to an intermediary fact check response behaves exactly the same as a basic fact response.\n</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>subscribe</p>",url:"https://docs.joinself.com/zero/subscribe/"},{value:"Disconnecting",label:"<p>You should gracefully manage the client disconnection by calling close method. If a connection is not gracefully closed Self messaging servers will kill that connection after one minute.\n\r@client.close   client.Close()   client.close()   \r </p><p>setup</p><p>disconnecting</p><p>shut down</p><p>stop</p><p>close</p>",url:"https://docs.joinself.com/setup/disconnect/"},{value:"Modifiers for fact requests",label:"<p>A fact request accepts some modifiers for example\nCID Passing the cid or conversation id, you\u0026rsquo;ll be able to modify the default random uuid for that request, and easily identify the related response.\nexp_timeout Timeout in seconds after which the request will expire. Useful if you want your fact request to be valid just for a specific period of time. It defaults to 900 seconds.\n</p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>modifiers</p><p>options</p>",url:"https://docs.joinself.com/facts/custom/"},{value:"Zero knowledge fact responses",label:"<p>This is similar to the fact request, the only difference in this case is that the attestation.value will always be a boolean indicating if your check is accomplished or not.\n</p><p>fact</p><p>anonymous</p><p>zero knowledge</p><p>zero</p><p>intermediary</p><p>response</p>",url:"https://docs.joinself.com/zero/response/"},{value:"Subscribe to responses",label:"<p>Users can respond to authentication requests by accepting or rejecting them. On the other hand, you won’t receive asynchronous notifications for requests which have timed out.\nYou can subscribe to authentication responses with this snippet\n\r@client.authentication.subscribe do |auth_res|\rputs resp.status\rend\r \rclient.MessagingService().Subscribe(\u0026quot;identities.authenticate.req\u0026quot;, func(m *messaging.Message)) {\r// manage the response\r}\r \rclient.messaging().subscribe(\u0026quot;identities.authenticate.req\u0026quot;, (res: any): any =\u0026gt; {\r// manage the response\r})\r \r\r </p><p></p>",url:"https://docs.joinself.com/authentication/subscription/"},{value:"Subscribe to fact response",label:"<p>As the user also has the option to accept or reject a fact request, the response also comes with a status property and some helpers like the authentication response.\nAdditionally a fact response comes with a list of attestations for the requested fact.\nSubscribing to a facts response is similar to authentication.\n\r@client.facts.subscribe do |resp|\r# GOTO Deal with the response for details\rend\r \r// TBD\r \rsdk.facts().subscribe((res: any): any =\u0026gt; {\r// GOTO Deal with the response for details\r})\r \r\r </p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>subscribe</p><p>response</p>",url:"https://docs.joinself.com/facts/subscribe/"},{value:"Dealing with responses",label:"<p>\r\rif resp.accepted?\rp \u0026quot;accepted\u0026quot;\relsif resp.rejected?\rp \u0026quot;rejected\u0026quot;\relsif resp.unauthorized?\rp \u0026quot;unauthorized\u0026quot;\relsif resp.errored?\rp \u0026quot;errored\u0026quot;\relse\rp \u0026quot;unkonwn status\u0026quot;\rend\r// Or simply access the status string p resp.status \n\r// Go SDK will return an error for unsuccessful\r// responses\rerr = authService.Request(\u0026quot;1112223334\u0026quot;)\rif err != nil {\rlog.Fatal(\u0026quot;auth returned with: \u0026quot;, err)\r}\rlog.Println(\u0026quot;authentication succeeded\u0026quot;) \n\rtry {\rlet res = await client.authentication().request(\u0026quot;1112223334\u0026quot;)\rif(res.isAccepted() == true) {\rclient.logger.info(`${res.selfID} is now authenticated 🤘`)\r} else if(res.accepted == false) {\rclient.logger.warn(`${res.selfID} has rejected your authentication request`)\r} else {\rclient.logger.error(res.errorMessage)\r}\r} catch (error) {\rclient.logger.error(error.toString())\r}\r \r\r The interesting field in an authentication response is status. Valid values for status are:\naccepted The user has accepted the authentication request, so you can proceed authenticating it on your app.\nrejected The user has rejected the authentication request.\nunauthorized You’re unauthorized to interact with this user, let it know it needs to be connected to your app before continuing with an authentication process.\nerrored An internal error happened.\nDepending on the SDK there are different ways you can deal with different status, see some examples below\n</p><p></p>",url:"https://docs.joinself.com/authentication/response/"},{value:"Fact response",label:"<p>The fact response will comes with a status and the same list of helpers as we described on authentication to deal with it.\nAdditionally each fact of the response has a list of attestations let’s see how to process them.\n\rresp.facts.each do |fact|\rp fact.name\rfact.attestations do |a|\rp \u0026quot;received #{a.value} from #{a.source}/#{a.fact} signed by #{a.origin}\u0026quot;\rend\rend\r \rfor _, f := range resp.Facts {\rlog.Println(f.Fact, \u0026quot;:\u0026quot;, f.AttestedValues())\r}\r \rsdk.logger.info(res.attestationValuesFor(\u0027phone_number\u0027)[0])\r \r\r </p><p>fact</p><p>facts</p><p>request</p><p>requests</p><p>name</p><p>email</p><p>response</p>",url:"https://docs.joinself.com/facts/response/"},{value:"Joinself Docs",label:"<p></p>",url:"https://docs.joinself.com/"},{value:"Setup",label:"<p>What is self? Self is a free to use service that lets you prove you’re a real, live person and are who you say you are, all without revealing the detail of your identity. Self keeps your data safe, secure and anonymous.\nHow does it work? You download the Self mobile app for free and tell it some facts about you. Then you ask friends, family, colleagues or a recognised organisation (eg: a bank) to verify that your facts are true. Your name, age, location etc…\nThe facts are stored in your secret locker (personal data store) and are never shared with anyone, but when someone needs to know your age, Self can help you provide them with a verified answer, all while keeping your data safe, secure and anonymous.\n</p>",url:"https://docs.joinself.com/setup/"},{value:"Users / Apps",label:"<p>This feature allows you to manage your connections by permitting and revoking incoming messages from specific identities.\nDuring the app creation process you can define if your app permits connections from everyone, or just you. You can tweak this behaviour as shown below.\n</p>",url:"https://docs.joinself.com/users/"},{value:"Messaging",label:"<p>Self provides powerful tools to interact with your users through messages.\n Sending text messages Sending text messages with attached files Process incoming messages Message confirmations Edit messages Delete messages Direct response Groups creation Group messaging Leaving a group Group management (sub invite and leave)  </p>",url:"https://docs.joinself.com/messaging/"},{value:"Authentication",label:"<p>One of the core features of Self is the ability to authenticate identities.\nThere are different ways to approach authentication. Lets see how we can achieve this.\nBy default authentication requests will expire after 5 minutes, you can change this defaults with Expiry option.\n </p>",url:"https://docs.joinself.com/authentication/"},{value:"Facts",label:"<p>A Facts is a statement about an identity. Verified facts are facts that have been attested to by trusted issuer(s).\nA single fact can be verified by multiple issuers and so have multiple assertions. Verified facts are held by identities and can be shared with other identities (relying parties) who require them.\nFacts and related attestations are stored on the user’s device, so the user has full control over who can access its information.\nEach fact has the following properties:\nSources A fact’s source represents where this fact comes from, for example a DOB can come from different sources such as a passport or a driving license. By default this field is set with a wildcard “*” and the user will select the source on their device. Same happens if you specify multiple sources.\nAt the moment there are three different sources user_specified, passport and driving_license.\nAs this list is always growing, you can check the possible values on your SDK ruby-sdk and go-sdk.\nFact This is the name of the fact you want to request like display_name, email_address or phone_number.\nThe list of values by source is:\n user_specified: display_name, email_address and phone_number passport and _identity-card _: document_number, surname, given_names, date_of_birth, date_of_expiration, sex, nationality, _country_of_issuance. driving_license : document_number, surname, given_names, date_of_birth, date_of_issuance, date_of_expiration, address, issuing_authority, place_of_birth, country_of_issuance.  Attestations A list of verified attestations signed by an issuer. This only has content on fact request responses, and it contains a list of attestations for the current fact.\nExpected value When you send an intermediary fact check you expect the value of a user’s fact to be compared with an expected value, this field is where you will provide that value.\nOperator On an intermediary fact check this field contains the operator used to compare the expected value against the expected value. Valid operators can be found here\nFact requests Fact requests allow your app to request specific facts from identities on the Self-network.\nOnly verified facts can be requested\nThe approaches to request facts are similar to authentication, so let\u0026rsquo;s have a look at them.\nBy default fact requests will expire after 15 minutes, you can change this defaults with `Expiry` option.\r\r</p>",url:"https://docs.joinself.com/facts/"},{value:"Zero-knowledge",label:"<p>An easy to use zero knowledge fact checker allows developers to ask the questions they really need an answer to, and receive anonymised answers.\nThat means they need to worry less about running a secure compliant environment.\nHow do they work? Intermediary fact checks are useful when you want to run a check of a user’s verified fact without having to gain access to that fact.\nEg. You want to verify a user is over 18, but you don’t want to deal with their personal information. An intermediary fact check allows you to run a zero knowledge check on that information via a trusted intermediary.\nThis is useful both for you and your users because you can prove a fact without ever directly interacting to them.\n</p>",url:"https://docs.joinself.com/zero/"},{value:"Notify",label:"<p>It prompts the user with a push notification or badge with a specific message. The message will be available on the notifications screen.\n\r@client.messaging.notify \u0026quot;1234567890\u0026quot;, \u0026quot;Hello world!\u0026quot;   err := client.MessagingService().Notify(\u0026quot;1234567890\u0026quot;, \u0026quot;Hello world!\u0026quot;)   await sdk.messaging().notify(\u0026quot;1234567890\u0026quot;, \u0026quot;Hello world!\u0026quot;)   \r </p><p>notify</p><p>notifications</p><p>push notification</p>",url:"https://docs.joinself.com/notify/"},{value:"Categories",label:"<p></p>",url:"https://docs.joinself.com/categories/"},{value:"Tags",label:"<p></p>",url:"https://docs.joinself.com/tags/"}];$("#search").autocomplete({source:a}).data("ui-autocomplete")._renderItem=function(b,a){return $("<li>").append("<a href="+a.url+' + " &quot;" +  >'+a.value+"</a>"+a.label).appendTo(b)}})</script>
</div>
</div>
</div>
</div>
</header>
<section class=section>
<div class=container>
<div class="row justify-content-center">
<div class="col-12 text-center">
<h2 class=section-title>Explore by feature</h2>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/setup/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-settings icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Setup</h3>
<p class=mb-0>Learn how to create and setup your Self app</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/users/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-user icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Users / Apps</h3>
<p class=mb-0>Connect, disconnect and request public information about users and apps</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/messaging/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-comment icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Messaging</h3>
<p class=mb-0>Interact with your users through messaging</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/authentication/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-lock icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Authentication</h3>
<p class=mb-0>Primary & Multi-factor authentication</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/facts/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-files icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Facts</h3>
<p class=mb-0>Request access to user&rsquo;s sensible data</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/zero/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-shield icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Zero-knowledge</h3>
<p class=mb-0>Zero knowledge proofs</p>
</a>
</div>
<div class="col-lg-4 col-sm-6 mb-4">
<a href=https://docs.joinself.com/notify/ class="px-4 py-5 bg-white shadow text-center d-block match-height">
<i class="ti-bell icon text-primary d-block mb-4"></i>
<h3 class="mb-3 mt-0">Notify</h3>
<p class=mb-0>Zero knowledge proofs</p>
</a>
</div>
</div>
</div>
</section>
<section>
<div class=container>
<div class=row>
<div class=col-12>
<div class="section px-3 bg-white shadow text-center">
<h2 class=mb-4>Didn&rsquo;t find an answer to your question?</h2>
<p class=mb-4>Want to know how the Self Network can solve problems specific to your business?</p>
<a href=https://www.joinself.com/contact-us class="btn btn-primary">contact us</a>
</div>
</div>
</div>
</div>
</section>
<footer class="section pb-4">
<div class=container>
<div class="row align-items-center">
<div class="col-md-8 text-md-left text-center">
<p class="mb-md-0 mb-4">© Self Group Ltd. 2022</p>
</div>
<div class="col-md-4 text-md-right text-center">
<ul class=list-inline>
<li class=list-inline-item>
<a class="text-color d-inline-block p-2" href=https://twitter.com/futureoftrust aria-label=Twitter><i class=ti-twitter-alt></i></a>
</li>
<li class=list-inline-item>
<a class="text-color d-inline-block p-2" href=https://github.com/joinself/ aria-label=Github><i class=ti-github></i></a>
</li>
<li class=list-inline-item>
<a class="text-color d-inline-block p-2" href=https://www.linkedin.com/company/joinself/ aria-label=Linkedin><i class=ti-linkedin></i></a>
</li>
</ul>
</div>
</div>
</div>
</footer>
<script src=https://docs.joinself.com/js/script.min.js></script>
</body>
</html>